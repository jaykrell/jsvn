#include <stdio.h>#include "j1.h"extern const jk_pack_spec1_t jk_java_classfile_pack_specs1[] ={	jk_make_pack_spec(jk_java_packed_classfile_t, jk_java_classfile_t, magic, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile_t, jk_java_classfile_t, minor_version, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile_t, jk_java_classfile_t, major_version, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile_t, jk_java_classfile_t, constant_pool_count, jk_endian_big),};extern jk_pack_specn_t jk_java_classfile_pack_spec1 ={	jk_endian_big,	jk_number_of(jk_java_classfile_pack_specs1),	jk_java_classfile_pack_specs1};voidjk_reverse_memory(	unsigned char * p,	unsigned count	){	unsigned char * q = (p + count);	while (p < q)	{		*p++ = *--q;	}}voidjk_copy_memory(	unsigned char * to,	const unsigned char * from,	unsigned count	){	memcpy(to, from, count);}voidjk_copy_memory_reverse(	unsigned char * to,	const unsigned char * from,	unsigned count	){	while (count != 0)	{		*to++ = from[--count];	}}voidjk_zero_memory(	void * p,	unsigned n    ){	memset(p, 0, n);}longjk_unpack(	unsigned endian,	const void * vpacked_buffer,	void * vunpacked_buffer,	const jk_pack_spec1_t * specs,	unsigned n	){	long err = -1;	unsigned i = 0;	unsigned j = 0;	const unsigned char * packed_buffer = (const unsigned char *)vpacked_buffer;	unsigned char * unpacked_buffer = (unsigned char*)vunpacked_buffer;	union {		unsigned long i;		unsigned char c[sizeof(unsigned long)];	} uhost_endian = { 1 };	unsigned host_endian = uhost_endian.c[0];	unsigned endian_factor = (host_endian << 1) | endian;	unsigned sign_byte_index = 0;	void (*copy)(unsigned char *, const unsigned char *, unsigned) = 0;	switch (endian_factor)	{		case 0:			copy = jk_copy_memory;			sign_byte_index = 1;			break;		case 1:			copy = jk_copy_memory_reverse;			sign_byte_index = 0;			break;		case 2:			copy = jk_copy_memory_reverse;			sign_byte_index = 1;			break;		case 3:			copy = jk_copy_memory;			sign_byte_index = 0;			break;	}	for (i = 0 ; i != n ; ++i)	{		const jk_pack_spec1_t spec = specs[i];		unsigned char const * const packed_field = packed_buffer + spec.packed_offset;		unsigned char * const unpacked_field = unpacked_buffer + spec.unpacked_offset;		unsigned number_of_bytes_to_copy = 0;		unsigned number_of_packed_bytes_to_skip = 0;		unsigned number_of_unpacked_bytes_to_skip = 0;		if (spec.unpacked_size == spec.packed_size)		{			number_of_bytes_to_copy = spec.packed_size;			number_of_packed_bytes_to_skip = 0;			number_of_unpacked_bytes_to_skip = 0;		}		else if (spec.unpacked_size > spec.packed_size)		{			memset(				unpacked_field,				(spec.is_signed && (packed_field[sign_byte_index ? (spec.packed_size - 1) : 0]) & 0x80) ? spec.is_signed : 0,				spec.unpacked_size				);			number_of_bytes_to_copy = spec.packed_size;			number_of_packed_bytes_to_skip = 0;			if (host_endian == jk_endian_big)				number_of_unpacked_bytes_to_skip = (spec.unpacked_size - number_of_bytes_to_copy);			else				number_of_unpacked_bytes_to_skip = 0;		}		else /* spec.unpacked_size < spec.packed_size */		{			number_of_bytes_to_copy = spec.unpacked_size;			number_of_unpacked_bytes_to_skip = 0;			if (endian == jk_endian_big)				number_of_packed_bytes_to_skip = (spec.packed_size - number_of_bytes_to_copy);			else				number_of_packed_bytes_to_skip = 0;		}		(*copy)(			unpacked_field + number_of_unpacked_bytes_to_skip,			packed_field + number_of_packed_bytes_to_skip,			number_of_bytes_to_copy			);	}	err = 0;	return err;}longjk_compute_packed_or_unpacked_size(	jk_pack_specn_t * p,	unsigned packed_or_unpacked	){	long err = -1;	if ((packed_or_unpacked ? p->packed_size : p->unpacked_size) == 0)	{		unsigned max = 0;		unsigned n = p->number_of_elements;		const jk_pack_spec1_t * specs = p->elements;		for ( ; n != 0 ; ++specs , --n )		{			unsigned i = 				(packed_or_unpacked ? (specs->packed_size + specs->packed_offset)								    : (specs->unpacked_size + specs->unpacked_offset));			if (i > max)			{				max = i;			}		}		packed_or_unpacked ? (p->packed_size = max) : (p->unpacked_size = max);	}	err = 0;	return err;}longjk_compute_packed_size(jk_pack_specn_t * p){	return jk_compute_packed_or_unpacked_size(p, 1);}longjk_compute_unpacked_size(jk_pack_specn_t * p){	return jk_compute_packed_or_unpacked_size(p, 0);}unsigned jk_align_integer(unsigned n){	unsigned m = 15;		return (n + m) & ~m;}longjk_file_open_for_read(	jk_file_t * f,	const char * path	){	long err = -1;	const char * openmode = "rb";	f->stdio_file = fopen(path, openmode);		if (f->stdio_file == 0) goto exit;	f->openmode = openmode;	f->path = path;	err = 0;exit:	return err;}longjk_file_close(	jk_file_t * f	){		if (f->stdio_file != 0)	{		fclose((FILE*)f->stdio_file);		f->stdio_file = 0;	}	return 0;}longjk_file_read(	jk_file_t * f,	void * buffer,	unsigned bytes_to_read,	unsigned * bytes_read /* optional */	){	size_t n = fread(buffer, 1, bytes_to_read, (FILE*)f->stdio_file);	if (bytes_read != 0)	{		*bytes_read = (unsigned)n;	}	return 0;}longjk_file_read_and_unpack(	jk_file_t * f,	jk_pack_specn_t * spec,	void * packed_buffer,	unsigned packed_buffer_size,	void * unpacked_buffer,	unsigned unpacked_buffer_size	){	long err = -1;	unsigned bytes_read;	err = jk_compute_packed_size(spec);	if (err < 0) goto exit;	err = jk_compute_unpacked_size(spec);	if (err < 0) goto exit;	if (spec->packed_size > packed_buffer_size)		err = -__LINE__;	else if (spec->unpacked_size > unpacked_buffer_size)		err = -__LINE__;	if (err < 0) goto exit;	err = jk_file_read(f, packed_buffer, spec->packed_size, &bytes_read);	if (err < 0) goto exit;	if (bytes_read != spec->packed_size)		err = -__LINE__;	if (err < 0) goto exit;	err = jk_unpack(spec->endian, packed_buffer, unpacked_buffer, spec->elements, spec->number_of_elements);	if (err < 0) goto exit;			err= 0;exit:	return err;}typedef struct jk_dump_struct_t {	unsigned     number_of_fields;	const struct jk_dump_field_t * fields;} jk_dump_struct_t;typedef struct jk_dump_field_t {	unsigned offset;	const char * name;	const char * format;} jk_dump_field_t;longjk_dump_struct(	const char * prefix,	const void * vbase,	const jk_dump_struct_t * desc	){	const char * base = (const char*)vbase;	int name_length = 0;	int maximum_name_length = 0;	unsigned i = 0;	const jk_dump_field_t * field = 0;	char format[] = "%s%-*s : 0x%x\n";	for ( i = 0 ; i != desc->number_of_fields ; ++i )	{		field = &desc->fields[i];		name_length = (int)strlen(field->name);		if (name_length > maximum_name_length)			maximum_name_length = name_length;	}	for ( i = 0 ; i != desc->number_of_fields ; ++i )	{		field = &desc->fields[i];		printf(format, prefix, field->name, *(unsigned*)(base + field->offset));	}	return 0;}const jk_dump_field_t jk_dump_java_classfile_fields[] ={#define X(x) { jk_offsetof(jk_java_classfile_t, x), #x },	X(minor_version)	X(major_version)	X(constant_pool_count)#undef X};const jk_dump_struct_t jk_dump_java_classfile_struct ={	jk_number_of(jk_dump_java_classfile_fields),	jk_dump_java_classfile_fields};long jk_java_read_classfile(jk_java_classfile_t ** ppcf, const char * filepath){#pragma unused(ppcf)	union {		jk_java_packed_classfile_t a;	} packed_buffer;	jk_java_classfile_t classfile;	jk_file_t * file = &classfile.file;	long err = -1;	unsigned n = 0;		err = jk_file_open_for_read(file, filepath);	if (err < 0) goto exit;	err = jk_file_read_and_unpack(file, &jk_java_classfile_pack_spec1, &packed_buffer, sizeof(packed_buffer), &classfile, sizeof(classfile));	if (err < 0) goto exit;		n = jk_align_integer(sizeof(classfile));	jk_dump_struct("classfile.", &classfile, &jk_dump_java_classfile_struct); 	err = 0;exit:	return err;}int main(int argc, char ** argv){	if (argc > 1 && argv && argv[1])		jk_java_read_classfile(0, argv[1]);	return -1;}