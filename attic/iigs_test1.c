/*The intent is to build test cases to run on real IIGS hardware toderive the exact behavior of various soft switches and instructions.The intent is to build these test cases on native IIGS hardware usingnative 16bit tools, and possibly to run them in a native 8/16 bit environment (DOS 3.3, ProDOS, nascent emulator).The intent is that the test binaries are standalone.They will contain their own text output routines.They will not have any disk input/output capability.They will have their own 8bit loader stub.A tool will be written in C for converting the C compiler output into loadable binaries.	Primarily by prefixing it with jk_iigs_loader0Multi-file linking might be an option using the C linker, in which case we will convertthe OMF .exe (.sys/.s16) files, unless such tools already exist.*/typedef struct jk_iigs_loader1_params_t {	void* start;	void* reloc;	unsigned short (*umul2)(unsigned short, unsigned short);	unsigned long (*umul4)(unsigned long, unsigned long);	void (*main)();	unsigned short stack_save;} jk_iigs_loader1_params_t;void jk_iigs_loader0(void);void jk_iigs_loader0(void){/* This is position independent. *//*:startclc ; switch to nativexcerep #30 ; 16 bit registerspea 0 ; data bank = 0 (why?)plbplbtsc ; get current stack for stack_save fieldtaxper stack[4095] ; establish our own 4k stackplatcsphx ; store save_stack field; push the rest of the jk_iigs_loader1_params on to the stackphkphkper umul4phkphkper umul2phkphkper relocphkphkper start; get the address of the jk_iigs_loader1_params and push ittscphkphkinc apha; position independent jsl to jk_iigs_loader1phkper ret - 1phkper jk_iigs_loader1 - 1rtl:ret - 1; return value of jk_iigs_loader1 is stack_save; restore it, back to emulation mode, and returntcssep #30secxcerts*/}unsigned jk_iigs_loader1(jk_iigs_loader1_params_t* params);unsigned jk_iigs_loader1(jk_iigs_loader1_params_t* params){/* This is position independent.The goal of this function is to relocate everything else and then call main.*/	(*params->main)();	return params->stack_save;}unsigned short umul2(unsigned short a, unsigned short b);unsigned short umul2(unsigned short a, unsigned short b){/* This is position independent and must be so. It must make no function calls. */	unsigned short x = 0;		while (a != 0 && b != 0)	{		if (b & 1)		{			x += a;		}		b >>= 1;		a <<= 1;	}	return x;}unsigned long umul4(unsigned long a, unsigned long b);unsigned long umul4(unsigned long a, unsigned long b){/* This is position independent and must be so. It must make no function calls. */	unsigned long x = 0;		while (a != 0 && b != 0)	{		if (b & 1)		{			x += a;		}		b >>= 1;		a <<= 1;	}	return x;}unsigned char stack[4096];unsigned short stack_save;typedef unsigned long jk_size_t, uint_ptr, ulong_ptr, dword, dword_ptr;const unsigned char jk_iigs_text_width = 40;const unsigned char jk_iigs_text_height = 24;unsigned char jk_iigs_text_x;unsigned char jk_iigs_text_y;unsigned char jk_iigs_text_mode; /* 0 40 columns, 1 80 columns */unsigned char jk_iigs_text_get_mode();unsigned char jk_iigs_text_get_mode(){	return jk_iigs_text_mode;}jk_size_t jk_strlen(const char* a);jk_size_t jk_strlen(const char* a){	const char* b = a;	while (*a) a++;	return (jk_size_t)(a - b);}void jk_strcpy(char* a, const char* b);void jk_strcpy(char* a, const char* b){	while ((*a++ = *b++) != 0) { }}void jk_strcat(char* a, const char* b);void jk_strcat(char* a, const char* b){	while (*a) a++;	while ((*a++ = *b++) != 0) { }}void jk_strrev(char* a);void jk_strrev(char* a){	char *b;	if (*a == 0)		return;	b = a;	while (*b) b++;	while (a < --b)	{		char c = *a;		*a++ = *b;		*b = c;	}}static const char jk_hex[] = "0123456789abcdef";void jk_utoa(unsigned u, char* a);staticvoid jk_utoa(unsigned u, char* a){	char* b = a;	do	{		*a++ = jk_hex[u  % 10];		u = (u / 10);	} while(u != 0);	*a++ = 0;	jk_strrev(b);}void jk_utox(unsigned u, char* a);void jk_utox(unsigned u, char* a){	char* b = a;	do	{		*a++ = jk_hex[u  % 16];		u = (u / 16);	} while(u != 0);	*a++ = 0;	jk_strrev(b);}static const unsigned short jk_iigs_text_line_address_table[24] ={	0x400, 0x480, 0x500, 0x580, 0x600, 0x680, 0x700, 0x780,	0x428, 0x4A8, 0x528, 0x5A8, 0x628, 0x6A8, 0x728, 0x7A8,	0x450, 0x4D0, 0x550, 0x5D0, 0x650, 0x6D0, 0x750, 0x7D0};void jk_iigs_assert_failed(const char* file, unsigned line, const char* expression);void jk_iigs_assert_failed(const char* file, unsigned line, const char* expression){	static const char a[] = "assertion failed";	char* z;	unsigned i;	unsigned j;	unsigned k;	unsigned m;	const char* string_pairs[4][2];	char line_string[65];		string_pairs[0][0] = "assertion failed";	string_pairs[0][1] = "";	string_pairs[1][0] = " file: ";	string_pairs[1][1] = (file ? file : "");	string_pairs[2][0] = " line: ";	string_pairs[2][1] = line_string;	string_pairs[3][0] = " expression: ";	string_pairs[3][1] = (expression ? expression : 0);		jk_utoa(line, line_string);	for (i = 0 ; i != 4 ; ++i)	{		z = (char*)jk_iigs_text_line_address_table[i];		k = 0;		for (j = 0 ; j != 2 && k != 40 ; ++j)		{			const char* s = string_pairs[i][j];			for (m = 0 ; s[m] && k != 40; ++m)			{				z[k] = (a[m] | 0x80);			}		}	}}unsigned char* jk_iigs_text_get_line_address_from_table(unsigned y);unsigned char* jk_iigs_text_get_line_address_from_table(unsigned y){	return (unsigned char*)(uint_ptr)jk_iigs_text_line_address_table[y];}unsigned char* jk_iigs_text_get_line_address_computed(unsigned y);unsigned char* jk_iigs_text_get_line_address_computed(unsigned y){	return (unsigned char*)(0x400 + ((y & 7) * 0x80) + ((y >> 3) * 40));}unsigned char* jk_iigs_text_get_line_address(unsigned y);unsigned char* jk_iigs_text_get_line_address(unsigned y){	return jk_iigs_text_get_line_address_from_table(y);}unsigned char* jk_iigs_text_get_char_address(unsigned x, unsigned y);unsigned char* jk_iigs_text_get_char_address(unsigned x, unsigned y){	unsigned char text_mode = jk_iigs_text_get_mode();	return jk_iigs_text_get_line_address(y) + (x >> text_mode) + ((x & text_mode) ? 0 : 0x10000);}void jk_iigs_text_plot_horizontal_line(unsigned x1, unsigned x2, unsigned y, unsigned ch);void jk_iigs_text_plot_horizontal_line(unsigned x1, unsigned x2, unsigned y, unsigned ch){	unsigned char text_mode = jk_iigs_text_get_mode();	unsigned char *line_address = jk_iigs_text_get_line_address(y);		if (text_mode)	{	}	else	{		memset(line_address + x1, ch, x2 - x1);	}}void jk_iigs_text_plot_char(unsigned x, unsigned y, unsigned ch);void jk_iigs_text_plot_char(unsigned x, unsigned y, unsigned ch){	*jk_iigs_text_get_char_address(x, y) = (0x80 | ch);}void jk_iigs_newline();void jk_iigs_newline(){	jk_iigs_text_plot_horizontal_line(jk_iigs_text_x, jk_iigs_text_width, jk_iigs_text_y, ' ');	jk_iigs_text_y += 1;	if (jk_iigs_text_y >= jk_iigs_text_height)	{		jk_iigs_text_y = 0;	}}void jk_iigs_text_advance();void jk_iigs_text_advance(){	jk_iigs_text_x += 1;	if (jk_iigs_text_x >= jk_iigs_text_width)	{		jk_iigs_text_x = 0;		jk_iigs_text_y += 1;		if (jk_iigs_text_y >= jk_iigs_text_height)		{			jk_iigs_text_y = 0;		}	}}void jk_iigs_print_char(char ch);void jk_iigs_print_char(char ch){	jk_iigs_text_plot_char(jk_iigs_text_x, jk_iigs_text_y, ch);	jk_iigs_text_advance();}void jk_iigs_print_string(const char *s);void jk_iigs_print_string(const char *s){	while (*s)	{		jk_iigs_print_char(*s);		s += 1;	}}void jk_iigs_test();void jk_iigs_test(){	jk_iigs_print_string("hello world");	jk_iigs_newline();	jk_iigs_print_string("hello world again");}int main(){	unsigned u;	char s[65] = "abc";		printf("%d\n", umul2(1, 0));	printf("%d\n", umul2(0, 1));	printf("%d\n", umul2(1, 1));	printf("%d\n", umul2(1, 2));	printf("%d\n", umul2(2, 1));	printf("%d\n", umul2(2, 3));	printf("%d\n", umul2(3, 2));	printf("%d\n", umul2(3, 3));	printf("%d\n", umul2(1, 100));	printf("%d\n", umul2(1, 101));	printf("%d\n", umul2(2, 100));	printf("%d\n", umul2(2, 101));	printf("%d\n", umul2(3, 100));	printf("%d\n", umul2(3, 101));	printf("%d\n", umul2(7, 8));	printf("%d\n", umul2(2, 10000));	printf("%d\n", umul2(2, 30000));	for (u = 0 ; u != 24 ; ++u)	{		if (u != 0 && (u % 7) == 0)			printf("\n");		printf("%x ", (unsigned)(uint_ptr)jk_iigs_text_get_line_address_computed(u));		printf("%x ", (unsigned)(uint_ptr)jk_iigs_text_get_line_address_from_table(u));	}	printf("\n");		printf("%u\n", jk_strlen(s));	jk_strrev(s);	printf("'%s'\n", s);	jk_strcpy(s, "");	jk_strrev(s);	printf("'%s'\n", s);	jk_strcpy(s, "a");	jk_strrev(s);	printf("'%s'\n", s);	jk_strcat(s, "b");	jk_strrev(s);	printf("'%s'\n", s);		jk_utoa(0, s);	printf("%s\n", s);	jk_utoa(123, s);	printf("%s\n", s);	jk_utox(0, s);	printf("%s\n", s);	jk_utox(123, s);	printf("%s\n", s);		return 0;}