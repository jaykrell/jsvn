#include <stdio.h>#include <stdlib.h>typedef unsigned char jk_uint8_t, byte_t, jk_byte_t;typedef unsigned short jk_uint16_t;typedef unsigned long jk_uint32_t;typedef signed char jk_int8_t;typedef struct iigs_omf_segment_header_disk_t {	byte_t disk_size[4];       /* 0x00  bytecnt  */	byte_t zeros_at_end[4];    /* 0x04  resspc   */	byte_t memory_size[4];     /* 0x08  length   */	byte_t reserved1;          /* 0x0C           */	byte_t label_length;       /* 0x0D  lablen   */	byte_t number_length;      /* 0x0E  numlen   */	byte_t version;            /* 0x0F           */	byte_t bank_size[4];       /* 0x10           */	byte_t kind[2];            /* 0x14           */	byte_t reserved2[2];       /* 0x16           */	byte_t origin[4];          /* 0x18  org      */	byte_t align[4];           /* 0x1C           */	byte_t big_endian;         /* 0x20  numsex   */	byte_t revision;           /* 0x21           */	byte_t segment_number[2];  /* 0x22  segnum   */	byte_t entry[4];           /* 0x24           */	byte_t offset_to_names[2]; /* 0x28  dispname */	byte_t offset_to_data[2];  /* 0x2A  dispdata */	byte_t temp_origin[4];     /* 0x2C  temporg  */} iigs_omf_segment_header_disk_t;typedef struct iigs_omf_segment_header_t {	jk_uint32_t disk_size;	jk_uint32_t zeros_at_end;	jk_uint32_t memory_size;	jk_uint32_t bank_size;	jk_uint32_t entry;	jk_uint32_t temp_origin;	jk_uint32_t origin;	jk_uint32_t align;	jk_uint16_t kind;	jk_uint16_t segment_number;	jk_uint16_t offset_to_names;	jk_uint16_t offset_to_data;	jk_uint8_t label_length;	jk_uint8_t number_length;	jk_uint8_t version;	jk_uint8_t revision;	jk_uint8_t big_endian;	jk_uint32_t data_size; /* disk_size - offset_to_data */	char loadname[11];	char* name;	byte_t* data;} iigs_omf_segment_header_t;jk_uint32_t getu4le(const byte_t* q);jk_uint32_t getu4le(const byte_t* q){	jk_uint32_t x = 0;	x |= q[3];	x <<= 8;	x |= q[2];	x <<= 8;	x |= q[1];	x <<= 8;	x |= q[0];	return x;}jk_uint16_t getu2le(const byte_t* q);jk_uint16_t getu2le(const byte_t* q){	jk_uint16_t x = 0;	x |= q[1];	x <<= 8;	x |= q[0];	return x;}voidiigs_omf_segment_header_from_disk(	iigs_omf_segment_header_disk_t* d,	iigs_omf_segment_header_t* o	);voidiigs_omf_segment_header_from_disk(	iigs_omf_segment_header_disk_t* d,	iigs_omf_segment_header_t* o	){	byte_t* p = (byte_t*)d;#define X4(x) o->x = getu4le(p); p += 4#define X2(x) o->x = getu2le(p); p += 2	X4(disk_size);	X4(zeros_at_end);	X4(memory_size);	++p; /* reserved */	o->label_length = *p++;	o->number_length = *p++;	o->version = *p++;	X4(bank_size);	X2(kind);	p += 2; /* reserved */	X4(origin);	X4(align);	o->big_endian = *p++;	o->revision = *p++;	X2(segment_number);	X4(entry);	X2(offset_to_names);	X2(offset_to_data);	X4(temp_origin);#undef X4#undef X2}typedef struct iigs_omf_reloc_t {	jk_uint8_t size; /* number of bytes to relocate */	jk_int8_t shift;	jk_uint32_t offset;	jk_uint32_t value; /* value if based at 0 */} iigs_omf_reloc_t;voidiigs_omf_unpack_reloc(	jk_byte_t* p,	iigs_omf_reloc_t* reloc	);voidiigs_omf_unpack_reloc(	jk_byte_t* p,	iigs_omf_reloc_t* reloc	){	reloc->size = *p++;	reloc->shift = *p++;	reloc->offset = getu4le(p);	p += 4;	reloc->value = getu4le(p);	p += 4;}typedef struct iigs_omf_compressed_reloc_t {	jk_uint8_t size; /* number of bytes to relocate */	jk_int8_t shift;	jk_uint16_t offset;	jk_uint16_t value; /* value if based at 0 */} iigs_omf_compressed_reloc_t;voidiigs_omf_unpack_compressed_reloc(	jk_byte_t* p,	iigs_omf_compressed_reloc_t* reloc	);voidiigs_omf_unpack_compressed_reloc(	jk_byte_t* p,	iigs_omf_compressed_reloc_t* reloc	){	reloc->size = *p++;	reloc->shift = *p++;	reloc->offset = getu2le(p);	p += 2;	reloc->value = getu2le(p);	p += 2;}unsigned long get_unsigned_little_endian(const byte_t* b, unsigned n);unsigned long get_unsigned_little_endian(const byte_t* b, unsigned n){	unsigned long x = 0;	unsigned u;	for (u = n ; u != 0 ; --u)	{		x <<= 8;		x |= b[u - 1];	}	return x;}#if 0typedef struct iigs_disassembler_functions_t iigs_disassembler_functions_t;typedef struct iigs_disassembler_t iigs_disassembler_t;typedef struct iigs_omf_disassembler_t iigs_omf_disassembler_t;typedef unsigned (*iigs_disassembler_function_is_at_end_t)(iigs_disassembler_t*);typedef unsigned (*iigs_disassembler_function_is_next_byte_constant_t)(iigs_disassembler_t*);typedef jk_byte_t (*iigs_disassembler_function_get_next_constant_byte_t)(iigs_disassembler_t*);typedef const char* (*iigs_disassembler_function_get_next_symbolic_operand_t)(iigs_disassembler_t*);typedef const char* (*iigs_disassembler_function_resolve_constant_to_symbol_t)(iigs_disassembler_t*, unsigned long constant);typedef void (*iigs_disassembler_function_printf_t)(iigs_disassembler_t*, const char*, ...);struct iigs_disassembler_functions_t{	iigs_disassembler_function_is_at_end_t is_at_end;	iigs_disassembler_function_is_next_byte_constant_t is_next_byte_constant;	iigs_disassembler_function_get_next_constant_byte_t get_next_constant_byte;	iigs_disassembler_function_get_next_symbolic_operand_t get_next_symbolic_operand;	iigs_disassembler_function_resolve_constant_to_symbol_t resolve_constant_to_symbol;	iigs_disassembler_function_printf_t printf;};struct iigs_disassembler_t{	const iigs_disassembler_functions_t* functions;};struct iigs_omf_disassembler_t{	iigs_disassembler_functions_t* functions;	iigs_omf_segment_header_t* omf_header;	unsigned long position;	char buffer[256];};#endifvoidiigs_omf_disassemble(	const byte_t* bytes,	unsigned long length	);voidiigs_omf_disassemble(	const byte_t* bytes,	unsigned long length	){	unsigned long left = length;	unsigned u = 0;	unsigned done = 0;	unsigned operand_size = 0;	unsigned long operand = 0;	unsigned opcode = 0;	for (u = 0 ; (!done) && u < length ; )	{		operand_size = 0;		opcode = bytes[u];		u += 1;		left -= 1;		switch (opcode)		{			default:				done = 1;				break;			case 0x22:				if (left != 0)				{					operand_size = ((left >= 3) ? 3 : (unsigned)left);					operand = get_unsigned_little_endian(bytes + u, operand_size);					printf("    jsl %x", operand);				}				else				{					printf("    jsl ");				}				break;			case 0xF4:				if (left >= 2)				{					operand_size = 2;					operand = getu2le(bytes + u);					printf("    pea %x", operand);				}				else				{					printf("    pea ");				}				break;		}		u += operand_size;	}	if (u > length)	{		printf(" invalid disassembly\n");	}}voidiigs_omf_segment_data_dump(	iigs_omf_segment_header_t* o	);voidiigs_omf_segment_data_dump(	iigs_omf_segment_header_t* o	){	byte_t* data = o->data;	jk_uint32_t data_size = o->data_size;	jk_uint32_t position = 0;	unsigned end  = 0;	unsigned opcode = 0;	unsigned long size = 0;	unsigned expression = 0;	union {		unsigned long align;		unsigned long origin;		iigs_omf_reloc_t reloc;		iigs_omf_compressed_reloc_t compressed_reloc;	} u;	unsigned label_length = o->label_length;	unsigned specific_label_length = 0;	const char* label_start = 0;	unsigned number_length = o->number_length;	while (!end)	{		if (position >= data_size)			break;		opcode = *data;		data += 1;		size = 0;		switch (opcode)		{			case 0x00:				printf(" end\n");				end = 1;				size = 0;				break;			default:				{					unsigned u;					size = opcode;					printf(" const opcode=0x%x, size=0x%lx, 0x", opcode, size);					for (u = 0 ; u != size ; ++u)					{						printf("%02x", data[u]);					}					printf("\n");					iigs_omf_disassemble(data, size);					printf("\n");				}				break;			case 0xE0:				u.align = getu4le(data);				size = 4;				printf(" align opcode=0x%x, align=0x%lx\n", opcode, u.align);				break;			case 0xE1:				u.origin = getu4le(data);				size = 4;				printf(" origin opcode=0x%x, origin=0x%lx\n", opcode, u.origin);				break;			case 0xE2:				size = 10;				iigs_omf_unpack_reloc(data, &u.reloc);				printf(" reloc opcode=0x%x\n", opcode);				printf("  size 0x%x\n", u.reloc.size);				printf("  size 0x%x\n", u.reloc.shift);				printf("  size 0x%lx\n", (unsigned long)u.reloc.offset);				printf("  size 0x%lx\n", (unsigned long)u.reloc.value);				break;			case 0xE3:				size = 14;				printf(" interseg opcode=0x%x\n", opcode);				break;			case 0xE4:				printf(" using opcode=0x%x\n", opcode);				size = (label_length ? label_length : *data);				break;			case 0xE5:				printf(" strong opcode=0x%x\n", opcode);				size = (label_length ? label_length : *data);				break;			case 0xE6:				printf(" global opcode=0x%x\n", opcode);				size = 4 + (label_length ? label_length : *data);				break;			case 0xE7:				printf(" gequ opcode=0x%x\n", opcode);				size = 4 + (label_length ? label_length : *data);				expression = 1;				break;			case 0xE8:				printf(" mem opcode=0x%x\n", opcode);				size = (2 * number_length);				break;			case 0xE9:				printf(" undefined 0x%x\n", opcode);				break;			case 0xEA:				printf(" undefined 0x%x\n", opcode);				break;			case 0xEB:				size = 1;				expression = 1;				printf(" expr opcode=0x%x size=0x%lx\n", opcode, size);				break;			case 0xEC:				printf(" zexpr opcode=0x%x\n", opcode);				size = 1;				expression = 1;				break;			case 0xED:				printf(" bexpr opcode=0x%x\n", opcode);				size = 1;				expression = 1;				break;			case 0xEE:				printf(" relexpr opcode=0x%x\n", opcode);				size = (1 + number_length);				expression = 1;				break;			case 0xEF:				printf(" local opcode=0x%x\n", opcode);				size = 4 + (label_length ? label_length : *data);				break;			case 0xF0:				printf(" equ opcode=0x%x\n", opcode);				size = 4 + (label_length ? label_length : *data);				expression = 1;				break;			case 0xF1:				printf(" ds opcode=0x%x\n", opcode);				size = number_length;				break;			case 0xF2:				printf(" lconst opcode=0x%x\n", opcode);				size = 4 + getu4le(data);				break;			case 0xF3:				printf(" lexpr opcode=0x%x\n", opcode);				size = 1;				expression = 1;				break;			case 0xF4:				printf(" entry opcode=0x%x\n", opcode);				size = 6;				expression = 1;				break;			case 0xF5:				size = 6;				iigs_omf_unpack_compressed_reloc(data, &u.compressed_reloc);				printf(" compressed reloc opcode=0x%x\n", opcode);				printf("  size 0x%x\n", u.compressed_reloc.size);				printf("  size 0x%x\n", u.compressed_reloc.shift);				printf("  size 0x%x\n", u.compressed_reloc.offset);				printf("  size 0x%x\n", u.compressed_reloc.value);				break;			case 0xF6:				size = 7;				printf(" compressed interseg opcode=0x%x\n", opcode);				break;			case 0xF7:				size = getu4le(data);				printf(" super compressed relocation dictionary opcode=0x%x, size=0x%lx\n", opcode, size);				break;			case 0xF8:			case 0xF9:			case 0xFA:				printf(" undefined 0x%x\n", *data);				break;			case 0xFB:				size = getu4le(data);				printf(" general reserved opcode=0x%x, size=0x%lx\n", opcode, size);				break;			case 0xFC:			case 0xFD:			case 0xFE:			case 0xFF:				size = getu4le(data);				printf(" general reserved opcode=0x%x, size=0x%lx\n", opcode, size);				break;		}		data += size;		if (expression)		{			unsigned expression_done = 0;			unsigned label = 0;			unsigned number = 0;			unsigned expression_opcode = 0;			unsigned expression_operation_size = 0;			expression = 0;			printf("  omf expression:\n");			while (!expression_done)			{				expression_opcode = *data;				expression_operation_size = 0;				data += 1;				label = 0;				number = 0;				switch (expression_opcode)				{					case 0:						expression_done = 1;						break;					default:						printf("   unknown expression opcode 0x%x\n", expression_opcode);						expression_done = 1;						break;											case 0x01:					case 0x02:					case 0x03:					case 0x04:					case 0x05:					case 0x06:					case 0x07:					case 0x08:					case 0x09:					case 0x0A:					case 0x0B:					case 0x0C:					case 0x0D:					case 0x0E:					case 0x0F:					case 0x10:					case 0x11:					case 0x12:					case 0x13:					case 0x14:					case 0x15:					case 0x80:						break;					case 0x87:						number = 1;						break;					case 0x81:					case 0x82:					case 0x83:					case 0x84:					case 0x85:					case 0x86:						label = 1;						expression_operation_size = 1;						break;				}				if (number)				{					expression_operation_size += number_length;				}				if (label)				{					if (label_length != 0)					{						specific_label_length = label_length;						label_start = (const char*)(data + size);					}					else					{						label_start = (const char*)(data + size + 1);						specific_label_length = (unsigned char)*(data + size);					}					printf("%.*s\n", (int)specific_label_length, label_start);					expression_operation_size += specific_label_length;									}				data += expression_operation_size;			}		}	}Exit:	;}voidiigs_omf_segment_header_dump(	iigs_omf_segment_header_t* o	);voidiigs_omf_segment_header_dump(	iigs_omf_segment_header_t* o	){	const char* prefix = "";	const char* suffix = "\n";	unsigned kind = o->kind;#define X(x) \	printf("%s" #x ": %lx%s", prefix, (unsigned long)o->x, suffix)#define Xs(x) \	if (o->x) \		printf("%s" #x ": \"%s\"%s", prefix, o->x, suffix)		Xs(name);	X(disk_size);	X(zeros_at_end);	X(memory_size);	X(label_length);	X(number_length);	X(version);	X(revision);	X(bank_size);	{		const char* suffix = "";		X(kind);	}	switch (kind & 0x1F)	{		case 0x00: printf(" %s", "code"); break;		case 0x01: printf(" %s", "data"); break;		case 0x02: printf(" %s", "jump-table"); break;		case 0x04: printf(" %s", "pathnames"); break;		case 0x08: printf(" %s", "library-dictionary"); break;		case 0x10: printf(" %s", "initialization"); break;		case 0x12: printf(" %s", "direct-page/stack"); break;	}	if (kind & 0x100)		printf(" %s", "bank-relative");	if (kind & 0x200)		printf(" %s", "skip");	if (kind & 0x400)		printf(" %s", "reload");	if (kind & 0x800)		printf(" %s", "absolute-bank");	if ((kind & 0x1000) == 0)		printf(" %s", "special-ok");	if (kind & 0x2000)		printf(" %s", "position-independent");	if (kind & 0x4000)		printf(" %s", "private");	if (kind & 0x8000)		printf(" %s", "dynamic");	else		printf(" %s", "static");	printf("%s", suffix);	X(origin);	X(align);	X(big_endian);	X(segment_number);	X(entry);	X(offset_to_names);	X(offset_to_data);	X(temp_origin);	Xs(loadname);#undef X#undef Xx}void jk_realloc(void** pp, size_t n);void jk_realloc(void** pp, size_t n){	void* p = realloc(*pp, n);	if (p != NULL)	{		*pp = p;	}}void iigs_dump_omf(const char* filename);void iigs_dump_omf(const char* filename){	FILE* file = 0;	iigs_omf_segment_header_disk_t d = { 0 };	iigs_omf_segment_header_t o = { 0 };	iigs_omf_segment_header_t* headers = 0;	char* name_buffer = 0;	char name_buffer11[11];	size_t name_buffer_length = 0;	size_t name_length = 0;	unsigned segment_number = 0;	unsigned long file_position_at_start_of_header = 0;		if (filename == 0)		goto Exit;			file = fopen(filename, "rb");	if (file == 0)		goto Exit;			while (1)	{		memset(&d, 0, sizeof(d));		memset(&o, 0, sizeof(o));		if (fread(&d, 1, sizeof(d), file) != sizeof(d))			goto Exit;		iigs_omf_segment_header_from_disk(&d, &o);		if (fseek(file, file_position_at_start_of_header + o.offset_to_names, SEEK_SET) == -1)			goto Exit;		if (o.label_length == 0)		{			if (fread(name_buffer11, 1, 11, file) != 11)				goto Exit;							memcpy(o.loadname, name_buffer11, 10);			o.loadname[10] = 0;						name_length = (unsigned char)name_buffer11[10];			o.name = (char*)malloc(name_length + 1);			if (o.name == NULL)				goto Exit;			o.name[name_length] = 0;			if (fread(o.name, 1, name_length, file) != name_length)				goto Exit;		}		else		{			name_buffer_length = (10 + o.label_length);			jk_realloc((void**)&name_buffer, name_buffer_length);			if (name_buffer == NULL)				goto Exit;			if (fread(name_buffer, 1, name_buffer_length, file) != name_buffer_length)				goto Exit;						memcpy(o.loadname, name_buffer, 10);			o.loadname[10] = 0;			o.name = (char*)malloc(o.label_length + 1);			if (o.name == NULL)				goto Exit;			memcpy(o.name, name_buffer + 10, o.label_length);			o.name[o.label_length] = 0;		}		printf("segment header #%u ----------------------\n", segment_number);		iigs_omf_segment_header_dump(&o);		if (fseek(file, file_position_at_start_of_header + o.offset_to_data, SEEK_SET) == -1)			goto Exit;				o.data_size = (o.disk_size - o.offset_to_data);		o.data = (byte_t*)malloc(o.data_size);		if (o.data == NULL)			goto Exit;					if (fread(o.data, 1, o.data_size, file) != o.data_size)			goto Exit;		printf("segment data #%u ----------------------\n", segment_number);		iigs_omf_segment_data_dump(&o);					file_position_at_start_of_header += o.disk_size;		segment_number += 1;	}		Exit:	if (file != 0)		fclose(file);	free(headers);	free(name_buffer);	free(o.name);	free(o.data);}int main(int argc, char** argv){	iigs_dump_omf(argv[1]);}