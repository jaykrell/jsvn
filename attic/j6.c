#include <stdio.h>#include "j1.h"extern const jk_pack_spec1_t jk_java_classfile_pack_specs1[] ={	jk_make_pack_spec(jk_java_packed_classfile1_t, jk_java_classfile_t, magic, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile1_t, jk_java_classfile_t, minor_version, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile1_t, jk_java_classfile_t, major_version, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile1_t, jk_java_classfile_t, constant_pool_count, jk_endian_big),};extern const jk_pack_spec1_t jk_java_classfile_pack_specs2[] ={	jk_make_pack_spec(jk_java_packed_classfile2_t, jk_java_classfile_t, access_flags, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile2_t, jk_java_classfile_t, this_class, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile2_t, jk_java_classfile_t, super_class, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile2_t, jk_java_classfile_t, interfaces_count, jk_endian_big),};extern jk_pack_specn_t jk_java_classfile_pack_spec1 ={	jk_endian_big,	jk_number_of(jk_java_classfile_pack_specs1),	jk_java_classfile_pack_specs1};voidjk_reverse_memory(	unsigned char * p,	unsigned count	){	unsigned char * q = (p + count);	while (p < q)	{		*p++ = *--q;	}}voidjk_copy_memory(	unsigned char * to,	const unsigned char * from,	unsigned count	){	memcpy(to, from, count);}voidjk_copy_memory_reverse(	unsigned char * to,	const unsigned char * from,	unsigned count	){	while (count != 0)	{		*to++ = from[--count];	}}voidjk_zero_memory(	void * p,	unsigned n    ){	memset(p, 0, n);}longjk_unpack(	unsigned endian,	const void * vpacked_buffer,	void * vunpacked_buffer,	const jk_pack_spec1_t * specs,	unsigned n	){	long err = -1;	unsigned i = 0;	unsigned j = 0;	const unsigned char * packed_buffer = (const unsigned char *)vpacked_buffer;	unsigned char * unpacked_buffer = (unsigned char*)vunpacked_buffer;	union {		unsigned long i;		unsigned char c[sizeof(unsigned long)];	} uhost_endian = { 1 };	unsigned host_endian = uhost_endian.c[0];	unsigned endian_factor = (host_endian << 1) | endian;	unsigned sign_byte_index = 0;	void (*copy)(unsigned char *, const unsigned char *, unsigned) = 0;	switch (endian_factor)	{		case 0:			copy = jk_copy_memory;			sign_byte_index = 1;			break;		case 1:			copy = jk_copy_memory_reverse;			sign_byte_index = 0;			break;		case 2:			copy = jk_copy_memory_reverse;			sign_byte_index = 1;			break;		case 3:			copy = jk_copy_memory;			sign_byte_index = 0;			break;	}	for (i = 0 ; i != n ; ++i)	{		const jk_pack_spec1_t spec = specs[i];		unsigned char const * const packed_field = packed_buffer + spec.packed_offset;		unsigned char * const unpacked_field = unpacked_buffer + spec.unpacked_offset;		unsigned number_of_bytes_to_copy = 0;		unsigned number_of_packed_bytes_to_skip = 0;		unsigned number_of_unpacked_bytes_to_skip = 0;		if (spec.unpacked_size == spec.packed_size)		{			number_of_bytes_to_copy = spec.packed_size;			number_of_packed_bytes_to_skip = 0;			number_of_unpacked_bytes_to_skip = 0;		}		else if (spec.unpacked_size > spec.packed_size)		{			memset(				unpacked_field,				(spec.is_signed && (packed_field[sign_byte_index ? (spec.packed_size - 1) : 0]) & 0x80) ? spec.is_signed : 0,				spec.unpacked_size				);			number_of_bytes_to_copy = spec.packed_size;			number_of_packed_bytes_to_skip = 0;			if (host_endian == jk_endian_big)				number_of_unpacked_bytes_to_skip = (spec.unpacked_size - number_of_bytes_to_copy);			else				number_of_unpacked_bytes_to_skip = 0;		}		else /* spec.unpacked_size < spec.packed_size */		{			number_of_bytes_to_copy = spec.unpacked_size;			number_of_unpacked_bytes_to_skip = 0;			if (endian == jk_endian_big)				number_of_packed_bytes_to_skip = (spec.packed_size - number_of_bytes_to_copy);			else				number_of_packed_bytes_to_skip = 0;		}		(*copy)(			unpacked_field + number_of_unpacked_bytes_to_skip,			packed_field + number_of_packed_bytes_to_skip,			number_of_bytes_to_copy			);	}	err = 0;	return err;}longjk_compute_packed_or_unpacked_size(	jk_pack_specn_t * p,	unsigned packed_or_unpacked	){	long err = -1;	if ((packed_or_unpacked ? p->packed_size : p->unpacked_size) == 0)	{		unsigned max = 0;		unsigned n = p->number_of_elements;		const jk_pack_spec1_t * specs = p->elements;		for ( ; n != 0 ; ++specs , --n )		{			unsigned i = 				(packed_or_unpacked ? (specs->packed_size + specs->packed_offset)								    : (specs->unpacked_size + specs->unpacked_offset));			if (i > max)			{				max = i;			}		}		packed_or_unpacked ? (p->packed_size = max) : (p->unpacked_size = max);	}	err = 0;	return err;}longjk_compute_packed_size(jk_pack_specn_t * p){	return jk_compute_packed_or_unpacked_size(p, 1);}longjk_compute_unpacked_size(jk_pack_specn_t * p){	return jk_compute_packed_or_unpacked_size(p, 0);}unsigned jk_align_integer(unsigned n){	unsigned m = 15;		return (n + m) & ~m;}longjk_file_open_for_read(	jk_file_t * file,	const char * file_path	){	long err = -1;	const char * openmode = "rb";	file->stdio_file = fopen(file_path, openmode);		if (file->stdio_file == 0) goto exit;	file->openmode = openmode;	file->file_path = file_path;	err = 0;exit:	return err;}longjk_file_close(	jk_file_t * file	){		if (file->stdio_file != 0)	{		fclose((FILE*)file->stdio_file);		file->stdio_file = 0;	}	return 0;}longjkp_file_read_direct(	jk_file_t * file,	void * buffer,	unsigned bytes_to_read,	unsigned * bytes_read /* optional */	){	size_t n = fread(buffer, 1, bytes_to_read, (FILE*)file->stdio_file);	if (bytes_read != 0)	{		*bytes_read = (unsigned)n;	}	return 0;}longjk_file_read_and_unpack(	jk_file_t * file,	jk_pack_specn_t * spec,	unsigned packed_buffer_size,	void * unpacked_buffer,	unsigned unpacked_buffer_size	){	long err = -1;	unsigned bytes_read = 0;	void * packed_buffer = 0;	err = jk_compute_packed_size(spec);	if (err < 0) goto exit;	err = jk_compute_unpacked_size(spec);	if (err < 0) goto exit;	if (spec->packed_size > packed_buffer_size)		err = -__LINE__;	else if (spec->unpacked_size > unpacked_buffer_size)		err = -__LINE__;	if (err < 0) goto exit;	err = jk_file_read_get_buffer(file, &packed_buffer, spec->packed_size, &bytes_read);	if (err < 0) goto exit;	if (bytes_read != spec->packed_size)		err = -__LINE__;	if (err < 0) goto exit;	err = jk_unpack(spec->endian, packed_buffer, unpacked_buffer, spec->elements, spec->number_of_elements);	if (err < 0) goto exit;			err= 0;exit:	return err;}typedef struct jk_dump_struct_t {	unsigned     number_of_fields;	const struct jk_dump_field_t * fields;} jk_dump_struct_t;typedef struct jk_dump_field_t {	unsigned offset;	const char * name;	const char * format;} jk_dump_field_t;longjk_dump_struct(	const char * prefix,	const void * vbase,	const jk_dump_struct_t * desc	){	const char * base = (const char*)vbase;	int name_length = 0;	int maximum_name_length = 0;	unsigned i = 0;	const jk_dump_field_t * field = 0;	char format[] = "%s%-*s : 0x%x\n";	unsigned u;	for ( i = 0 ; i != desc->number_of_fields ; ++i )	{		field = &desc->fields[i];		name_length = (int)strlen(field->name);		if (name_length > maximum_name_length)			maximum_name_length = name_length;	}	for ( i = 0 ; i != desc->number_of_fields ; ++i )	{		field = &desc->fields[i];		u = *(unsigned*)(base + field->offset);		if (u >= 16)			printf("%s%-*s 0x%x (0n%u)\n", prefix, maximum_name_length, field->name, u, u);		else			printf("%s%-*s %u\n", prefix, maximum_name_length, field->name, u);	}	return 0;}const jk_dump_field_t jk_dump_java_classfile_fields[] ={#define X(x) { jk_offsetof(jk_java_classfile_t, x), #x },	X(minor_version)	X(major_version)	X(constant_pool_count)#undef X};const jk_dump_struct_t jk_dump_java_classfile_struct ={	jk_number_of(jk_dump_java_classfile_fields),	jk_dump_java_classfile_fields};longjk_file_read_ahead(	jk_file_t * file,	unsigned n	){	file->buffer.read_ahead += n;	return 0;}longjk_file_read_copy(	jk_file_t * file,	void * buffer,	unsigned bytes_to_read,	unsigned * bytes_read	){	void * my_buffer = 0;	long err = 0;	err = jk_file_read_get_buffer(file, &my_buffer, bytes_to_read, bytes_read);	if (err < 0) goto exit;	memcpy(buffer, my_buffer, *bytes_read);	err = 0;exit:	return err;}longjk_file_read_get_buffer(	jk_file_t * file,	void ** out_buffer,	unsigned bytes_to_read,	unsigned * out_bytes_read	){	long err;	char * new_buffer;	unsigned new_buffer_size;	unsigned keep_all_bytes;	unsigned buffer_size;	unsigned read_ahead;	unsigned bytes_to_read_plus_read_ahead;	unsigned bytes_read;	unsigned bytes_in_buffer;	unsigned position;	char * buffer;	bytes_in_buffer = file->buffer.bytes_in_buffer;	position = file->buffer.position;	buffer = file->buffer.buffer;	/* fast path -- there are enough bytes */	if (bytes_to_read <= (bytes_in_buffer - position))	{		*out_buffer = (buffer + position);		*out_bytes_read = bytes_read;		file->buffer.position = (position + bytes_to_read);		return 0;	}	err = 0;	new_buffer = 0;	new_buffer_size = 0;	keep_all_bytes = 0;	buffer_size = 0;	read_ahead = 0;	bytes_to_read_plus_read_ahead = 0;	bytes_read = 0;	buffer_size = file->buffer.buffer_size;	keep_all_bytes = file->buffer.keep_all_bytes;	read_ahead = file->buffer.read_ahead;	bytes_to_read_plus_read_ahead = bytes_to_read + read_ahead;	/* slow path -- there are not enough bytes */	new_buffer_size = jk_max(buffer_size, bytes_to_read_plus_read_ahead);	if (keep_all_bytes)	{		new_buffer_size += buffer_size;	}	if (new_buffer_size > buffer_size)	{		new_buffer_size = jk_align_integer(new_buffer_size);		new_buffer  = (char*)malloc(new_buffer_size);		if (new_buffer == 0)		{			err = -__LINE__;			goto exit;		}		if (keep_all_bytes)		{			memcpy(new_buffer, buffer, bytes_in_buffer);		}		free(buffer);		file->buffer.buffer = new_buffer;		buffer = new_buffer;		new_buffer = 0;		file->buffer.buffer_size = new_buffer_size;		buffer_size = new_buffer_size;	}	if (!keep_all_bytes && (buffer_size - bytes_in_buffer) < bytes_to_read)	{		memmove(buffer, buffer + position, bytes_in_buffer - position);		file->buffer.position = 0;		position = 0;	}	err = jkp_file_read_direct(file, buffer + position, buffer_size - bytes_in_buffer, &bytes_read);	if (err < 0) goto exit;	file->buffer.bytes_in_buffer += bytes_read;	if (bytes_read > bytes_to_read)	{		bytes_read = bytes_to_read;	}	*out_buffer = (buffer + position);	file->buffer.position = (position + bytes_read);	*out_bytes_read = bytes_read;	err = 0;exit:	if (new_buffer)	{		free(new_buffer);	}	return err;}unsigned jk_get_big_endian_u2(unsigned char * a){	return ((unsigned)a[0]) << 16) | a[1];}unsigned long jk_get_big_endian_u4(unsigned char * a){	return ((unsigned long)a[0]) << 24)			| ((unsigned long)a[1]) << 16)			| ((unsigned)a[2]) << 8)			| a[3]			;}extern const float jk_java_positive_infinity_float = (1.0f / 0.0f);extern const float jk_java_negative_infinity_float = -(1.0f / 0.0f);extern const double jk_java_positive_infinity_double = (1.0d / 0.0d);extern const double jk_java_negative_infinity_double = -(1.0d / 0.0d);extern const float jk_java_nan_float = (0.0f / 0.0f);extern const double jk_java_nan_double = (0.0d / 0.0d);typedef struct jk_longlong_t{	signed long high;	unsigned long low;} jk_longlong_t;typedef struct jk_ulonglong_t{	unsigned long high;	unsigned long low;} jk_ulonglong_t;jk_ulonglong_tjk_longlong_to_ulonglong(jk_longlong_t a){	jk_ulonglong b;	b.low = a.low;	b.high = (unsigned long)a.high;	return b;}jk_ulonglong_t*jk_longlong_to_ulonglong_pointer(jk_longlong_t * a){	return (jk_ulonglong_t*)a;}voidjk_long_add_with_carry_in(long * a, long b, long c, unsigned carry){	*a = b + c + carry;}voidjk_long_add_with_carry_out(long * a, long b, long c, unsigned * carry){	long aa = b + c;	*a = aa;	*carry = ((aa < 0) != (b < 0)) && ((aa < 0) != (c < 0));}voidjk_long_add_with_carry_in_and_out(long * a, long b, long c, unsigned * carry){	long aa = b + c + *carry;	*a = aa;	*carry = ((aa < 0) != (b < 0)) && ((aa < 0) != (c < 0));}voidjk_ulong_add_with_carry_in(unsigned long * a, unsigned long b, unsigned long c, unsigned carry){	*a = b + c + *carry;}voidjk_ulong_add_with_carry_out(unsigned long * a, unsigned long b, unsigned long c, unsigned * carry){	unsigned long aa = b + c;	*a = aa;	*carry = ((aa < b) || (aa < c));}voidjk_ulong_add_with_carry_in_and_out(unsigned long * a, unsigned long b, unsigned long c, unsigned * carry){	unsigned long aa = b + c + *carry;	*a = aa;	*carry = ((aa < b) || (aa < c));}voidjk_longlong_add(jk_longlong_t * a, jk_longlong_t b, jk_longlong_t c){	unsigned carry;	jk_ulong_add_with_carry_out(&a->low, b.low, c.low, &carry);	jk_long_add_with_carry_in(&a->high, b.high, c.high, carry);}voidjk_ulonglong_add(jk_ulonglong_t * a, jk_ulonglong_t b, jk_ulonglong_t c){	unsigned carry;	jk_ulong_add_with_carry_out(&a->low, b.low, c.low, &carry);	jk_ulong_add_with_carry_in(&a->high, b.high, c.high, carry);}voidjk_longlong_from_long(jk_longlong_t * a, long b){	a->low = (long)b;	a->high = (b < 0) < -1 : +1;}voidjk_longlong_from_ulong(jk_longlong_t * a, unsigned long b){	a->low = (unsigned long)b;	a->high = 0;}voidjk_ulonglong_bitwise_and(jk_ulonglong_t * a, jk_ulonglong_t b, jk_ulonglong_t c){	a->low = (b.low & c.low);	a->high = (b.high & c.high);}voidjk_ulonglong_bitwise_or(jk_ulonglong_t * a, jk_ulonglong_t b, jk_ulonglong_t c){	a->low = (b.low | c.low);	a->high = (b.high | c.high);}voidjk_longlong_bitwise_and(jk_longlong_t * a, jk_longlong_t b, jk_longlong_t c){	jk_ulonglong_bitwise_and(jk_longlong_to_ulonglong_pointer(a), jk_longlong_to_ulonglong(b), jk_longlong_to_ulonglong(c));}voidjk_longlong_bitwise_or(jk_longlong_t * a, jk_longlong_t b, jk_longlong_t c){	jk_ulonglong_bitwise_or(jk_longlong_to_ulonglong_pointer(a), jk_longlong_to_ulonglong(b), jk_longlong_to_ulonglong(c));}unsignedjk_ulonglong_to_boolean(jk_ulonglong_t a){	return (a.high != 0 || a.low != 0);}unsignedjk_longlong_to_boolean(jk_longlong_t a){	return (a.high != 0 || a.low != 0);}unsignedjk_ulonglong_logical_and(jk_ulonglong_t a, jk_ulonglong_t b){	return jk_ulonglong_to_boolean(a) && jk_ulonglong_to_boolean(b);}unsignedjk_ulonglong_logical_or(jk_ulonglong_t a, jk_ulonglong_t b){	return jk_ulonglong_to_boolean(a) || jk_ulonglong_to_boolean(b);}unsignedjk_longlong_logical_and(jk_longlong_t a, jk_longlong_t b){	jk_ulonglong_logical_and(jk_longlong_to_ulonglong(a), jk_longlong_to_ulonglong(b));}unsignedjk_longlong_logical_or(jk_longlong_t a, jk_longlong_t b){	jk_ulonglong_logical_or(jk_longlong_to_ulonglong(a), jk_longlong_to_ulonglong(b));}voidjk_ulonglong_bitwise_not(jk_ulonglong_t * a, jk_ulonglong_t b){	a->low = ~b.low;	a->high = ~b.high;}voidjk_longlong_bitwise_not(jk_longlong_t * a, jk_longlong_t b){	jk_ulonglong_bitwise_not(jk_longlong_to_ulonglong_pointer(a), jk_longlong_to_ulonglong(b));}unsignedjk_ulonglong_logical_not(jk_ulonglong_t a){	return (a.high == 0 && a.low == 0);}unsignedjk_longlong_logical_not(jk_longlong_t a){	jk_ulonglong_logical_not(jk_longlong_to_ulonglong(a));}voidjk_ulonglong_left_shift(jk_ulonglong_t * a, jk_ulonglong_t b, unsigned shift){	if (shift >= 64)	{		a->low = 0;		a->high = 0;	}	else if (shift >= 32)	{		a->low = 0;		a->high = (b.low << (shift - 32));	}	else	{		unsigned long aa = b.low;		a->low = (aa << shift);		a->high = ((b.high << shift) | (aa >> (32 - shift));	}}voidjk_longlong_left_shift(jk_longlong_t * a, jk_longlong_t b, unsigned shift){	jk_ulonglong_left_shift(jk_longlong_to_ulonglong_pointer(a), jk_longlong_to_ulonglong(b), shift);}voidjk_ulonglong_right_shift(jk_ulonglong_t * a, jk_ulonglong_t b, unsigned shift){	if (shift >= 64)	{		a->low = 0;		a->high = 0;	}	else if (shift >= 32)	{		a->high = 0;		a->low = (b.high >> (shift - 32));	}	else	{		unsigned long aa = b.high;		a->high = (aa >> shift);		a->low = ((b.low >> shift) | (aa << (32 - shift));	}}voidjk_longlong_zero_fill_right_shift(jk_longlong_t * a, jk_longlong_t b, unsigned shift){	jk_ulonglong_right_shift(jk_longlong_to_ulonglong_pointer(a), jk_longlong_to_ulonglong(b), shift);}longjk_long_zero_fill_right_shift(long a, unsigned shift){	if (shift >= 32)		return 0;	else		return (long)(((unsigned long)a) >> shift);}longjk_long_with_n_right_bits_clear(unsigned n){	return (~0L << n);}longjk_long_with_n_right_bits_set(unsigned n){	return ~(~0L << n);}longjk_long_with_n_left_bits_clear(unsigned n){	return (long)(~0UL >> n);}longjk_long_with_n_left_bits_set(unsigned n){	return (long)~(~0UL >> n);}#define jk_bits_of(x) (sizeof(x)*8)longjk_long_sign_fill_right_shift(long a, unsigned shift){	if (shift >= jk_bits_of(a))		return (a < 0) ? (~0L) : 0;	else		return jk_long_zero_fill_right_shift(a, shift)) | ((a < 0) ? jk_long_with_n_left_bits_set(shift + 1) : 0);}voidjk_longlong_sign_fill_right_shift(jk_longlong_t * a, jk_longlong_t b, unsigned shift){	if (b.high >= 0)	{		jk_longlong_zero_fill_right_shift(a, b, shift);		return;	}	if (shift >= 64)	{		a->low = ~0UL;		a->high = ~0UL;	}	else if (shift >= 32)	{		a->high = ~0UL;		a->low = (b.high >> (shift - 32));	}	else	{		unsigned long aa = b.high;		a->high = jk_long_sign_fill_right_shift(aa, shift);		a->low = jk_long_zero_fill_right_shift(b.low, shift) | (aa << (32 - shift));	}}voidjk_ulong_multiply_to_ulonglong(jk_ulonglong_t * a, unsigned long b, unsigned long c){	unsigned long bl = (b & 0xffff);	unsigned long bh = (b >> 16);	unsigned long cl = (c & 0xffff);	unsigned long ch = (c >> 16);	jk_ulonglong_t aa;	if (bh == 0 && ch == 0)	{		a->low = bl * cl;		a->high = 0;		return;	}	aa.low = 0;	aa.high = 0;}voidjk_long_multiply_to_longlong(jk_longlong_t * a, long b, long c){}voidjk_ulonglong_multiply(jk_ulonglong_t * a, jk_ulonglong_t b, jk_ulonglong_t c){}voidjk_longlong_multiply(jk_longlong_t * a, jk_longlong_t b, jk_longlong_t c){}floatjk_java_convert_java_float_to_native_float(	unsigned char * bytes	){	long sign;	long exponent;	long mantissa;	unsigned long i;	float f;	i = jk_get_big_endian_u4(bytes);	if (bytes[0] == 0x7f || bytes[0] == 0xff)	{		if (i == 0x7f800000ul)		{			f = jk_java_positive_infinity_float;			goto exit;		}		else if (i == 0xff800000ul)		{			f = jk_java_negative_infinity_float;			goto exit;		}		else if ((i >= 0x7f800001ul && i <= 0x7ffffffful)				|| (i >= 0xff800001ul && i <= 0xfffffffful))		{			f = jk_java_nan_float;			goto exit;		}	}	sign = ((i >> 31) == 0) ? +1 : -1;	exponent = (i >> 23) & 0xff;	mantissa = (exponent == 0) ? ((i & 0x7fffff) << 1) : ((i & 0x7fffff) | 0x800000);	f = sign * mantissa * pow(2, e - 150);exit:	return f;}longjk_java_read_constantpool(	jk_java_classfile_t * classfile	){	long err = -__LINE__;	unsigned constants_read = 0;	unsigned constant_pool_count = classfile->constant_pool_count;	jk_java_constant_pool_t * constant_pool = &classfile->constant_pool;	jk_file_t * file = classfile->file;	unsigned char * buffer = 0;	unsigned bytes_read = 0;	unsigned char tags = 0;	tags = (unsigned char*)malloc(constant_pool_count);	if (tags == 0)	{		err = -__LINE__;		goto exit;	}	constant_pool->tags = tags;	err = jk_file_read_ahead(file, 3 * constant_pool_count);	if (err < 0) goto exit;	for ( constants_read = 0 ; constants_read != constant_pool_count ; ++constants_read )	{		err = jk_file_read_get_buffer(file, &buffer, 3, &buffer, &bytes_read);		if (err < 0) goto exit;		if (bytes_read != 3) { err = -__LINE__; goto exit; }		tag = buffer[0];		tags[constants_read] = tag;		switch (tag)		{		case jk_java_constant_class_tag:			words[constants_read] = jk_get_big_endiang_u2(buffer + 1);			break;		case jk_java_constant_fieldref_tag:		case jk_java_constant_methodref_tag:		case jk_java_constant_interfacemethodref_tag:			err = jk_file_read_get_buffer(file, &buffer, 2, &buffer, &bytes_read);			if (err < 0) goto exit;			if (bytes_read != 2) { err = -__LINE__; goto exit; }			buffer -= 5;		}	}	err = 0;exit:	return err;}long jk_java_read_classfile(jk_java_classfile_t ** ppcf, const char * filepath){#pragma unused(ppcf)	jk_java_classfile_t classfile;	jk_file_t * file = &classfile.file;	long err = -1;	unsigned n = 0;	jk_file_buffer_t file_buffer = { 0 };		err = jk_file_open_for_read(file, filepath);	if (err < 0) goto exit;	err = jk_file_read_and_unpack(file, &jk_java_classfile_pack_spec1, sizeof(jk_java_packed_classfile1_t), &classfile, sizeof(classfile));	if (err < 0) goto exit;		err = jk_java_read_constantpool(	n = jk_align_integer(sizeof(classfile));	jk_dump_struct("classfile.", &classfile, &jk_dump_java_classfile_struct); 	err = 0;exit:	return err;}int main(int argc, char ** argv){	if (argc > 1 && argv && argv[1])		jk_java_read_classfile(0, argv[1]);	return -1;}