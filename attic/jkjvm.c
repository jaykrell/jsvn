#include <limits.h>#include <stdio.h>#include <stdlib.h>#include "jkjvm.h"void jk_unused(void * p) { p = p;}long jk_malloc_allocator_allocate(jk_allocator_t * self, void ** pp, jksize_t n){	void * p;		jk_unused(self);		p = malloc(n);	*pp = p;	if (p == 0)		return -1;	return 0;}long jk_malloc_allocator_free(jk_allocator_t * self, void ** pp){	void * p;		jk_unused(self);	p = *pp;	*pp = 0;	free(p);	return 0;}long jk_malloc_allocator_realloc(jk_allocator_t * self, void ** pp, jksize_t n){ 	void * newp;		jk_unused(self);	newp = realloc(*pp, n);	if (newp == 0)		return -1;	*pp = newp;	return 0;}long jk_buffer_getsize(jk_buffer_t * self, jksize_t * pn){	*pn = self->size;	return 0;}long jk_buffer_get(jk_buffer_t * self, void ** pp){	*pp = self->p;	return 0;}long jk_buffer_ensuresize(jk_buffer_t * self, jksize_t size, jkbyte_t ** pp){	if (self->size >= size)	{		if (pp != 0)		{			*pp = self->p;		}		return 0;	}	return self->functions->setsize(self, size, pp);}long jk_buffer_setsize(jk_buffer_t * self, jksize_t size, jkbyte_t ** pp){	long status = 0;	void * p = 0;	jksize_t new_allocated_size;		if (self->allocated_size >= size)	{		self->size = size;		p = self->p;		goto exit;	}	new_allocated_size = self->allocated_size * 2;	if (new_allocated_size < size)	{		new_allocated_size = size;	}	status = self->allocator->functions->realloc(self->allocator, &self->p, new_allocated_size);	if (status < 0)	{		goto exit;	}	self->allocated_size = new_allocated_size;	self->size = size;	status = 0;exit:	if (p != 0 && pp != 0)	{		*pp = p;	}	return status;}long jkjvm_classfile_read_constantpool(jkjvm_class_t * cl){	long status;	jkjvm_constantpool_t * cp = &cl->constantpool;		status = jkjvm_classfile_read_u2(cl, &cp->count);	if (status < 0)		goto exit;exit:	return status;}const jkjvm_constant_info_t jkjvm_constant_info[]={	{ 0 }, /* 0 */	{ 1, 0 /* varible length */, sizeof(jkjvm_unresolved_constant_utf8_t) }, /* 1 */	{ 0 }, /* 2 */	{ 1, sizeof(jkjvm_unresolved_constant_integer_t) }, /* 3 */	{ 1, sizeof(jkjvm_unresolved_constant_float_t) }, /* 4 */	{ 2, sizeof(jkjvm_unresolved_constant_long_t) }, /* 5 */	{ 2, sizeof(jkjvm_unresolved_constant_double_t) }, /* 6 */	{ 1, sizeof(jkjvm_unresolved_constant_class_t) }, /* 7 */	{ 1, sizeof(jkjvm_unresolved_constant_string_t) }, /* 8 */	{ 1, sizeof(jkjvm_unresolved_constant_fieldref_t) }, /* 9 */	{ 1, sizeof(jkjvm_unresolved_constant_methodref_t) }, /* 10 */	{ 1, sizeof(jkjvm_unresolved_constant_interfacemethodref_t) }, /* 11 */	{ 1, sizeof(jkjvm_unresolved_constant_name_and_type_t) }, /* 12 */};