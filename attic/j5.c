#include <stdio.h>#include "j1.h"extern const jk_pack_spec1_t jk_java_classfile_pack_specs1[] ={	jk_make_pack_spec(jk_java_packed_classfile1_t, jk_java_classfile_t, magic, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile1_t, jk_java_classfile_t, minor_version, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile1_t, jk_java_classfile_t, major_version, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile1_t, jk_java_classfile_t, constant_pool_count, jk_endian_big),};extern const jk_pack_spec1_t jk_java_classfile_pack_specs2[] ={	jk_make_pack_spec(jk_java_packed_classfile2_t, jk_java_classfile_t, access_flags, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile2_t, jk_java_classfile_t, this_class, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile2_t, jk_java_classfile_t, super_class, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile2_t, jk_java_classfile_t, interfaces_count, jk_endian_big),};extern jk_pack_specn_t jk_java_classfile_pack_spec1 ={	jk_endian_big,	jk_number_of(jk_java_classfile_pack_specs1),	jk_java_classfile_pack_specs1};voidjk_reverse_memory(	unsigned char * p,	unsigned count	){	unsigned char * q = (p + count);	while (p < q)	{		*p++ = *--q;	}}voidjk_copy_memory(	unsigned char * to,	const unsigned char * from,	unsigned count	){	memcpy(to, from, count);}voidjk_copy_memory_reverse(	unsigned char * to,	const unsigned char * from,	unsigned count	){	while (count != 0)	{		*to++ = from[--count];	}}voidjk_zero_memory(	void * p,	unsigned n    ){	memset(p, 0, n);}longjk_unpack(	unsigned endian,	const void * vpacked_buffer,	void * vunpacked_buffer,	const jk_pack_spec1_t * specs,	unsigned n	){	long err = -1;	unsigned i = 0;	unsigned j = 0;	const unsigned char * packed_buffer = (const unsigned char *)vpacked_buffer;	unsigned char * unpacked_buffer = (unsigned char*)vunpacked_buffer;	union {		unsigned long i;		unsigned char c[sizeof(unsigned long)];	} uhost_endian = { 1 };	unsigned host_endian = uhost_endian.c[0];	unsigned endian_factor = (host_endian << 1) | endian;	unsigned sign_byte_index = 0;	void (*copy)(unsigned char *, const unsigned char *, unsigned) = 0;	switch (endian_factor)	{		case 0:			copy = jk_copy_memory;			sign_byte_index = 1;			break;		case 1:			copy = jk_copy_memory_reverse;			sign_byte_index = 0;			break;		case 2:			copy = jk_copy_memory_reverse;			sign_byte_index = 1;			break;		case 3:			copy = jk_copy_memory;			sign_byte_index = 0;			break;	}	for (i = 0 ; i != n ; ++i)	{		const jk_pack_spec1_t spec = specs[i];		unsigned char const * const packed_field = packed_buffer + spec.packed_offset;		unsigned char * const unpacked_field = unpacked_buffer + spec.unpacked_offset;		unsigned number_of_bytes_to_copy = 0;		unsigned number_of_packed_bytes_to_skip = 0;		unsigned number_of_unpacked_bytes_to_skip = 0;		if (spec.unpacked_size == spec.packed_size)		{			number_of_bytes_to_copy = spec.packed_size;			number_of_packed_bytes_to_skip = 0;			number_of_unpacked_bytes_to_skip = 0;		}		else if (spec.unpacked_size > spec.packed_size)		{			memset(				unpacked_field,				(spec.is_signed && (packed_field[sign_byte_index ? (spec.packed_size - 1) : 0]) & 0x80) ? spec.is_signed : 0,				spec.unpacked_size				);			number_of_bytes_to_copy = spec.packed_size;			number_of_packed_bytes_to_skip = 0;			if (host_endian == jk_endian_big)				number_of_unpacked_bytes_to_skip = (spec.unpacked_size - number_of_bytes_to_copy);			else				number_of_unpacked_bytes_to_skip = 0;		}		else /* spec.unpacked_size < spec.packed_size */		{			number_of_bytes_to_copy = spec.unpacked_size;			number_of_unpacked_bytes_to_skip = 0;			if (endian == jk_endian_big)				number_of_packed_bytes_to_skip = (spec.packed_size - number_of_bytes_to_copy);			else				number_of_packed_bytes_to_skip = 0;		}		(*copy)(			unpacked_field + number_of_unpacked_bytes_to_skip,			packed_field + number_of_packed_bytes_to_skip,			number_of_bytes_to_copy			);	}	err = 0;	return err;}longjk_compute_packed_or_unpacked_size(	jk_pack_specn_t * p,	unsigned packed_or_unpacked	){	long err = -1;	if ((packed_or_unpacked ? p->packed_size : p->unpacked_size) == 0)	{		unsigned max = 0;		unsigned n = p->number_of_elements;		const jk_pack_spec1_t * specs = p->elements;		for ( ; n != 0 ; ++specs , --n )		{			unsigned i = 				(packed_or_unpacked ? (specs->packed_size + specs->packed_offset)								    : (specs->unpacked_size + specs->unpacked_offset));			if (i > max)			{				max = i;			}		}		packed_or_unpacked ? (p->packed_size = max) : (p->unpacked_size = max);	}	err = 0;	return err;}longjk_compute_packed_size(jk_pack_specn_t * p){	return jk_compute_packed_or_unpacked_size(p, 1);}longjk_compute_unpacked_size(jk_pack_specn_t * p){	return jk_compute_packed_or_unpacked_size(p, 0);}unsigned jk_align_integer(unsigned n){	unsigned m = 15;		return (n + m) & ~m;}longjk_file_open_for_read(	jk_file_t * file,	const char * file_path	){	long err = -1;	const char * openmode = "rb";	file->stdio_file = fopen(file_path, openmode);		if (file->stdio_file == 0) goto exit;	file->openmode = openmode;	file->file_path = file_path;	err = 0;exit:	return err;}longjk_file_close(	jk_file_t * file	){		if (file->stdio_file != 0)	{		fclose((FILE*)file->stdio_file);		file->stdio_file = 0;	}	return 0;}longjkp_file_read_direct(	jk_file_t * file,	void * buffer,	unsigned bytes_to_read,	unsigned * bytes_read /* optional */	){	size_t n = fread(buffer, 1, bytes_to_read, (FILE*)file->stdio_file);	if (bytes_read != 0)	{		*bytes_read = (unsigned)n;	}	return 0;}longjk_file_read_and_unpack(	jk_file_t * file,	jk_pack_specn_t * spec,	unsigned packed_buffer_size,	void * unpacked_buffer,	unsigned unpacked_buffer_size	){	long err = -1;	unsigned bytes_read = 0;	void * packed_buffer = 0;	err = jk_compute_packed_size(spec);	if (err < 0) goto exit;	err = jk_compute_unpacked_size(spec);	if (err < 0) goto exit;	if (spec->packed_size > packed_buffer_size)		err = -__LINE__;	else if (spec->unpacked_size > unpacked_buffer_size)		err = -__LINE__;	if (err < 0) goto exit;	err = jk_file_read_get_buffer(file, &packed_buffer, spec->packed_size, &bytes_read);	if (err < 0) goto exit;	if (bytes_read != spec->packed_size)		err = -__LINE__;	if (err < 0) goto exit;	err = jk_unpack(spec->endian, packed_buffer, unpacked_buffer, spec->elements, spec->number_of_elements);	if (err < 0) goto exit;			err= 0;exit:	return err;}typedef struct jk_dump_struct_t {	unsigned     number_of_fields;	const struct jk_dump_field_t * fields;} jk_dump_struct_t;typedef struct jk_dump_field_t {	unsigned offset;	const char * name;	const char * format;} jk_dump_field_t;longjk_dump_struct(	const char * prefix,	const void * vbase,	const jk_dump_struct_t * desc	){	const char * base = (const char*)vbase;	int name_length = 0;	int maximum_name_length = 0;	unsigned i = 0;	const jk_dump_field_t * field = 0;	char format[] = "%s%-*s : 0x%x\n";	unsigned u;	for ( i = 0 ; i != desc->number_of_fields ; ++i )	{		field = &desc->fields[i];		name_length = (int)strlen(field->name);		if (name_length > maximum_name_length)			maximum_name_length = name_length;	}	for ( i = 0 ; i != desc->number_of_fields ; ++i )	{		field = &desc->fields[i];		u = *(unsigned*)(base + field->offset);		if (u >= 16)			printf("%s%-*s 0x%x (0n%u)\n", prefix, maximum_name_length, field->name, u, u);		else			printf("%s%-*s %u\n", prefix, maximum_name_length, field->name, u);	}	return 0;}const jk_dump_field_t jk_dump_java_classfile_fields[] ={#define X(x) { jk_offsetof(jk_java_classfile_t, x), #x },	X(minor_version)	X(major_version)	X(constant_pool_count)#undef X};const jk_dump_struct_t jk_dump_java_classfile_struct ={	jk_number_of(jk_dump_java_classfile_fields),	jk_dump_java_classfile_fields};longjk_file_read_ahead(	jk_file_t * file,	unsigned n	){	file->buffer.read_ahead += n;	return 0;}longjk_file_read_copy(	jk_file_t * file,	void * buffer,	unsigned bytes_to_read,	unsigned * bytes_read	){	void * my_buffer = 0;	long err = 0;	err = jk_file_read_get_buffer(file, &my_buffer, bytes_to_read, bytes_read);	if (err < 0) goto exit;	memcpy(buffer, my_buffer, *bytes_read);	err = 0;exit:	return err;}longjk_file_read_get_buffer(	jk_file_t * file,	void ** out_buffer,	unsigned bytes_to_read,	unsigned * out_bytes_read	){	long err;	char * new_buffer;	unsigned new_buffer_size;	unsigned keep_all_bytes;	unsigned buffer_size;	unsigned read_ahead;	unsigned bytes_to_read_plus_read_ahead;	unsigned bytes_read;	unsigned bytes_in_buffer;	unsigned position;	char * buffer;	bytes_in_buffer = file->buffer.bytes_in_buffer;	position = file->buffer.position;	buffer = file->buffer.buffer;	/* fast path -- there are enough bytes */	if (bytes_to_read <= (bytes_in_buffer - position))	{		*out_buffer = (buffer + position);		*out_bytes_read = bytes_read;		file->buffer.position = (position + bytes_to_read);		return 0;	}	err = 0;	new_buffer = 0;	new_buffer_size = 0;	keep_all_bytes = 0;	buffer_size = 0;	read_ahead = 0;	bytes_to_read_plus_read_ahead = 0;	bytes_read = 0;	buffer_size = file->buffer.buffer_size;	keep_all_bytes = file->buffer.keep_all_bytes;	read_ahead = file->buffer.read_ahead;	bytes_to_read_plus_read_ahead = bytes_to_read + read_ahead;	/* slow path -- there are not enough bytes */	new_buffer_size = jk_max(buffer_size, bytes_to_read_plus_read_ahead);	if (keep_all_bytes)	{		new_buffer_size += buffer_size;	}	if (new_buffer_size > buffer_size)	{		new_buffer_size = jk_align_integer(new_buffer_size);		new_buffer  = (char*)malloc(new_buffer_size);		if (new_buffer == 0)		{			err = -__LINE__;			goto exit;		}		if (keep_all_bytes)		{			memcpy(new_buffer, buffer, bytes_in_buffer);		}		free(buffer);		file->buffer.buffer = new_buffer;		buffer = new_buffer;		new_buffer = 0;		file->buffer.buffer_size = new_buffer_size;		buffer_size = new_buffer_size;	}	if (!keep_all_bytes && (buffer_size - bytes_in_buffer) < bytes_to_read)	{		memmove(buffer, buffer + position, bytes_in_buffer - position);		file->buffer.position = 0;		position = 0;	}	err = jkp_file_read_direct(file, buffer + position, buffer_size - bytes_in_buffer, &bytes_read);	if (err < 0) goto exit;	file->buffer.bytes_in_buffer += bytes_read;	if (bytes_read > bytes_to_read)	{		bytes_read = bytes_to_read;	}	*out_buffer = (buffer + position);	file->buffer.position = (position + bytes_read);	*out_bytes_read = bytes_read;	err = 0;exit:	if (new_buffer)	{		free(new_buffer);	}	return err;}longjk_java_read_constantpool(	jk_java_classfile_t * classfile	){	long err = -__LINE__;	unsigned bytes_available = 0;	unsigned extra_bytes_needed = 0;	unsigned bytes_read = 0;	unsigned constants_read = 0;	unsigned constant_pool_count = classfile->constant_pool_count;	jk_java_constant_pool_t * constant_pool = &classfile->constant_pool;	char * raw_data = 0;	unsigned current_position_in_raw_data = 0;	jk_file_read_ahead(3 * constant_pool_count);	for ( constants_read = 0 ; constants_read != constant_pool_count ; ++constants_read )	{		if (bytes_available == 0)		{			unsigned u = 0;			char * new_raw_data = 0;			new_raw_data = (char*)realloc(raw_data, extra_bytes_needed + bytes_read);			if (new_raw_data == 0)			{				err = jk_get_out_of_memory_error();				goto exit;			}			err = jk_file_read(raw_data + bytes_read, extra_bytes_needed, &u);			if (err < 0) goto exit;			bytes_read += u;			extra_bytes_needed -= u;			bytes_available += u;		}	}exit:	free(raw_data);	return err;}long jk_java_read_classfile(jk_java_classfile_t ** ppcf, const char * filepath){#pragma unused(ppcf)	jk_java_classfile_t classfile;	jk_file_t * file = &classfile.file;	long err = -1;	unsigned n = 0;	jk_file_buffer_t file_buffer = { 0 };		err = jk_file_open_for_read(file, filepath);	if (err < 0) goto exit;	err = jk_file_read_and_unpack(file, &jk_java_classfile_pack_spec1, sizeof(jk_java_packed_classfile1_t), &classfile, sizeof(classfile));	if (err < 0) goto exit;		err = jk_java_read_constantpool(	n = jk_align_integer(sizeof(classfile));	jk_dump_struct("classfile.", &classfile, &jk_dump_java_classfile_struct); 	err = 0;exit:	return err;}int main(int argc, char ** argv){	if (argc > 1 && argv && argv[1])		jk_java_read_classfile(0, argv[1]);	return -1;}