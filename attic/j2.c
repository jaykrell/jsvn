#include <stdio.h>#include "j1.h"extern const jk_pack_spec1_t jk_java_classfile_pack_specs1[] ={	jk_make_pack_spec(jk_java_packed_classfile_t, jk_java_classfile_t, magic, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile_t, jk_java_classfile_t, minor_version, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile_t, jk_java_classfile_t, major_version, jk_endian_big),	jk_make_pack_spec(jk_java_packed_classfile_t, jk_java_classfile_t, constant_pool_count, jk_endian_big),};extern jk_pack_specn_t jk_java_classfile_pack_spec1 ={	jk_endian_big,	jk_number_of(jk_java_classfile_pack_specs1),	jk_java_classfile_pack_specs1};voidreverse_memory(	unsigned char * p,	unsigned count	){	unsigned char * q = (p + count);	while (p < q)	{		*p++ = *--q;	}}voidcopy_memory_reverse(	unsigned char * to,	const unsigned char * from,	unsigned count	){	while (count != 0)	{		*to++ = from[--count];	}}voidzero_memory(	void * p,	unsigned n    ){	memset(p, 0, n);}longjk_unpack(	unsigned endian,	void * vpacked_buffer,	void * vunpacked_buffer,	const jk_pack_spec1_t * specs,	unsigned n	){#pragma unused(vpacked_buffer)#pragma unused(vunpacked_buffer)#pragma unused(specs)#pragma unused(n)	long err = -1;	unsigned i = 0;	unsigned j = 0;	unsigned char * packed_buffer = (unsigned char *)vpacked_buffer;	unsigned char * unpacked_buffer = (unsigned char*)vunpacked_buffer;	unsigned endian_flip = (endian == jk_endian_little);	union {		unsigned long i;		unsigned char c[sizeof(unsigned long)];	} uhost_endian = { 1 };	unsigned host_endian = uhost_endian.c[0];	unsigned endian_factor = (host_endian << 1) | endian;	for (i = 0 ; i != n ; ++i)	{		const jk_pack_spec1_t spec = specs[i];		unsigned char * packed_field = packed_buffer + spec.packed_offset;		unsigned char * unpacked_field = unpacked_buffer + spec.unpacked_offset;		signed char sign_byte = spec.is_signed;		signed unpacked_size_minus_packed_size = (spec.unpacked_size - spec.packed_size);		void (*copy)(unsigned char *, const unsigned char *, unsigned);		switch            ( ((unpacked_size_minus_packed_size < 0) << 3)			| ((unpacked_size_minus_packed_size > 0) << 2)			| endian_factor            )		{			case 0: /* packed_size == unpacked_size, same endian (big) */			case 3: /* packed_size == unpacked_size, same endian (little) */				copy_memory(unpacked_field, packed_field, spec.packed_size);				break;			case 1: /* packed_size == unpacked_size, reverse endian */			case 2: /* packed_size == unpacked_size, reverse endian */				copy_memory_reverse(unpacked_field, packed_field, spec.packed_size);				break;			case 4: /* unpacked_size > packed_size, same endian (big) */				copy_memory(unpacked_field + unpacked_size_minus_packed_size, packed_field, spec.packed_size);				memset(unpacked_field, (packed_field[0] & 0x80) ? spec.is_signed : 0, unpacked_size_minus_packed_size);				break;			case 7: /* unpacked_size > packed_size, same endian (little) */				copy_memory(unpacked_field, packed_field, spec.packed_size);				memset(unpacked_field + packed_size, (packed_field[0] & 0x80) ? spec.is_signed : 0, unpacked_size_minus_packed_size);				break;			case 5: /* unpacked_size > packed_size, reverse endian, host is big endian */				copy_memory_reverse(unpacked_field + unpacked_size_minus_packed_size, packed_field, spec.packed_size);				memset(unpacked_field, (packed_field[0] & 0x80) ? spec.is_signed : 0, unpacked_size_minus_packed_size);				break;			case 6: /* unpacked_size > packed_size, reverse endian, host is little endian */				copy_memory_reverse(unpacked_field, packed_field, spec.packed_size);				memset(unpacked_field + packed_size, (packed_field[0] & 0x80) ? spec.is_signed : 0, unpacked_size_minus_packed_size);				break;			case 8: /* unpacked_size < packed_size, same endian (big) */				copy_memory(unpacked_field, packed_field - unpacked_size_minus_packed_size, spec.unpacked_size);				break;			case 8|3: /* unpacked_size < packed_size, same endian (little) */				copy_memory(unpacked_field, packed_field, spec.unpacked_size);				break;			case 8|1: /* unpacked_size < packed_size, reverse endian, host is big endian */				copy_memory_reverse(unpacked_field, packed_field, spec.unpacked_size);				break;			case 8|2: /* unpacked_size < packed_size, reverse endian, host is little endian */				copy_memory_reverse(unpacked_field, packed_field - unpacked_size_minus_packed_size, spec.unpacked_size);				break;		}	}		return err;}longjk_compute_packed_or_unpacked_size(	jk_pack_specn_t * p,	unsigned packed_or_unpacked	){	long err = -1;	if ((packed_or_unpacked ? p->packed_size : p->unpacked_size) == 0)	{		unsigned max = 0;		unsigned n = p->number_of_elements;		const jk_pack_spec1_t * specs = p->elements;		for ( ; n != 0 ; ++specs , --n )		{			unsigned i = 				(packed_or_unpacked ? (specs->packed_size + specs->packed_offset)								    : (specs->unpacked_size + specs->unpacked_offset));			if (i > max)			{				max = i;			}		}		packed_or_unpacked ? (p->packed_size = max) : (p->unpacked_size = max);	}	err = 0;	return err;}longjk_compute_packed_size(jk_pack_specn_t * p){	return jk_compute_packed_or_unpacked_size(p, 1);}longjk_compute_unpacked_size(jk_pack_specn_t * p){	return jk_compute_packed_or_unpacked_size(p, 0);}unsigned jk_align_integer(unsigned n){	unsigned m = 15;		return (n + m) & ~m;}longjk_file_open_for_read(	jk_file_t * f,	const char * path	){	long err = -1;	f->stdio_file = fopen(path, "rb");		if (f->stdio_file == 0) goto exit;	f->openmode = "rb";	f->path = path;	err = 0;exit:	return err;}longjk_file_close(	jk_file_t * f	){		if (f->stdio_file != 0)	{		fclose((FILE*)f->stdio_file);		f->stdio_file = 0;	}	return 0;}longjk_file_read(	jk_file_t * f,	void * buffer,	unsigned bytes_to_read,	unsigned * bytes_read /* optional */	){	size_t n = fread(buffer, 1, bytes_to_read, (FILE*)f->stdio_file);	if (bytes_read != 0)	{		*bytes_read = n;	}	return 0;}longjk_file_read_and_unpack(	jk_file_t * f,	const jk_pack_specn_t * spec,	void * packed_buffer,	unsigned packed_buffer_size,	void * unpacked_buffer,	unsigned unpacked_buffer_size){#pragma unused(f)#pragma unused(spec)#pragma unused(packed_buffer)#pragma unused(packed_buffer_size)#pragma unused(unpacked_buffer)#pragma unused(unpacked_buffer_size)	long err = -1;	return -1;}long jk_java_read_classfile(jk_java_classfile_t ** ppcf, const char * filepath){#pragma unused(ppcf)	union {		jk_java_packed_classfile_t a;	} packed_buffer;	jk_java_classfile_t classfile;	jk_file_t * file = &classfile.file;	long err = -1;	unsigned n = 0;		err = jk_file_open_for_read(file, filepath);	if (err < 0) goto exit;	err = jk_file_read_and_unpack(file, &jk_java_classfile_pack_spec1, &packed_buffer, sizeof(packed_buffer), &classfile, sizeof(classfile));	if (err < 0) goto exit;		n = jk_align_integer(sizeof(classfile));	err = 0;exit:	return err;}int main(int argc, char ** argv){	for ( ;  *argv ; ++argv)	{		printf("%s\n", *argv);	}	return -1;}