#include <stdio.h>#include <time.h>/* #include "cursorctl.h" */#define number_of(x) (sizeof(x)/sizeof((x)[0]))voidgot_command(	FILE * out,	const char * command_name	){#pragma unused(out)#pragma unused(command_name)	fprintf(out, "%s\n", command_name);}voiderror(	const char * format,	...	){#pragma unused(format)}intfile_exists(const char * f){	FILE * g = 0;		g = fopen(f, "rb");	if (g != 0)		fclose(g);	return (g != 0);}voidget_commands(const char * filepath_in, const char * filepath_out, FILE * fileout1){	FILE * file = 0;	FILE * fileout2 = 0;	int ch = 0;	unsigned offset = 0;	unsigned dash_offset = 0;	unsigned command_name_length = 0;	char command_name[64];	enum state {		state_start,		state_start_newline,		state_dash,		state_in_command_name, 		state_in_command_help, 		state_in_command_help_newline,		state_eof	};	enum state state = state_start;	/* doing our own buffering here makes a substantial difference in MPW on Mac OS X	 *  -- under 1 second instead of 20 seconds.	 * We take under 1 second either way in MPW on Mac OS 9.	 */	char buffer[64];	const unsigned buffer_size = number_of(buffer);	unsigned number_of_characters_in_buffer = 0;	unsigned buffer_index = 0;		/*InitCursorCtl(0);*/	file = fopen(filepath_in, "rb");	if (file == NULL)	  goto exit;	if (fileout1 != 0)	  fileout2 = fileout1;	else	  fileout2 = fopen(filepath_out, "wb");	if (fileout2 == NULL)		goto exit;	while (1)	{		if (state == state_eof)			break;		/* SpinCursor(1); */		number_of_characters_in_buffer = fread(buffer, 1, buffer_size, file);		if (number_of_characters_in_buffer == 0)			break;		for (buffer_index = 0 ; state != state_eof && buffer_index != number_of_characters_in_buffer ; ++buffer_index)		{			int ch = 0;						if (state == state_eof)				break;			ch = buffer[buffer_index];			switch (state)			{			case state_in_command_help_newline:				switch (ch)				{				case EOF:					state = state_eof;					break;				case '-':					state = state_dash;					break;				case '\n': case '\r':					break;				default:					state = state_in_command_help;					break;				}				break;			case state_start_newline:				switch (ch)				{				case EOF:					state = state_eof;					break;				case '\n': case '\r':					break;				case '-':					state = state_dash;					break;				default:					state = state_start;					break;				}				break;			case state_start:				switch (ch)				{				case EOF:					state = state_eof;					break;				case '\n': case '\r':					state = state_start_newline;					break;				default:					break;				}				break;			case state_in_command_help:				switch (ch)				{				case EOF:					state = state_eof;					break;				case '\n': case '\r':					state = state_in_command_help_newline;					break;				default:					break;				}				break;			case state_in_command_name:				switch (ch)				{				case EOF:					state = state_eof;					break;				case '\t': case ' ': case '\n': case '\r':					command_name[command_name_length++] = 0;					got_command(fileout2, command_name);					command_name_length = 0;					command_name[0] = 0;					state = state_in_command_help;					break;				default:					if ((command_name_length + 2) >= number_of(command_name))					{						error("command name too long %s\n", command_name);						return;					}					command_name[command_name_length++] = ch;					break;				}				break;			case state_dash:				switch (ch)				{				case EOF:					state = state_eof;					break;				case '\t': case ' ': case '\n': case '\r':					break;				default:					command_name_length = 0;					command_name[command_name_length++] = ch;					if (command_name_length >= number_of(command_name))					{						error("command name too long %s\n", command_name);						return;					}					state = state_in_command_name;					break;				}			}		}	}exit:	if (file != 0)		fclose(file);	if (fileout2 != 0 && fileout2 != fileout1)		fclose(fileout2);}int main(int argc, char ** argv){	time_t t1;	time_t t2;		t1 = time(0);	if (argc >= 1 && argv != 0 && argv[1] != 0)	{		if (argc >= 2 && argv[2] != 0)			get_commands(argv[1], argv[2], 0);		else			get_commands(argv[1], 0, stdout);	}	t2 = time(0);	printf("%f\n", difftime(t2, t1));	return 0;}