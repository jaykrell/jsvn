#pragma once#include "j61.h"#define TARGET_API_MAC_CARBON 1//#include <iostream>//#include <Carbon.h>#include <Carbon/Carbon.h>#include <stdio.h>#include <MacMemory.h>#include <Files.h>#include <MacErrors.h>#include <vector>#include <string.h>#include <memory.h>//#include <wchar.h>inline void ZeroMemory(void* p, size_t size) { memset(p, 0, size); }class CMacError{	long m_Error;public:	CMacError(long Error);};void ThrowMacError(long Error);class CMacResLoad{	Boolean m_ResLoad;public:	CMacResLoad() { Init(false); }	CMacResLoad(Boolean ResLoad) { Init(ResLoad); }	~CMacResLoad() { Restore(); }	void Restore() { SetResLoad(m_ResLoad); }private:	void Save() { m_ResLoad = LMGetResLoad(); }	void Set(Boolean ResLoad) { SetResLoad(ResLoad); }	void Init(Boolean ResLoad) { Save(); Set(ResLoad); }};class CMacUseResFile{	bool m_Valid;	HANDLE m_PreviousResFile;public:	CMacUseResFile() : m_Valid(false), m_PreviousResFile(0) { }	~CMacUseResFile() { Restore(); }		void Save() { m_PreviousResFile = (HANDLE) (size_t) CurResFile(); }	void Set(HANDLE ResFile) { if (!m_Valid) Save(); UseResFile((short) (size_t) ResFile); }	void Restore() { if (m_Valid) { m_Valid = false; UseResFile((short) (size_t) m_PreviousResFile); } }};	class CMacFilePath{	std::vector<BYTE> m_Path;	FSSpec m_PathSpec;public:	CMacFilePath(PCWSTR a)	{		ZeroMemory(&m_PathSpec, sizeof(m_PathSpec));		ThrowMacError(Init(a));	}		const BYTE* GetPString() const { return &m_Path[0]; }	PCSTR GetCString() const { return (PCSTR) &m_Path[1]; }	const FSSpec* GetFSSpec() const { return &m_PathSpec; }	operator const FSSpec* () const { return GetFSSpec(); }	OSErr Init(PCWSTR a)	{		size_t Length = wcslen(a);		if (Length > 255)		{			throw "Path too long";		}		m_Path.resize(Length + 1);		m_Path[0] = (BYTE) Length;		size_t i = 0;		size_t j = 0;		for ( i = 0 ; i != Length ; ++i)		{			WCHAR ch = a[i];			if (ch == '/')			{				if (i == 0)					continue;				ch = ':';			}			m_Path[++j] = (BYTE)ch;		}		return FSMakeFSSpec(0, 0, &m_Path[0], &m_PathSpec);	}};class CMacFileHandle{	bool m_Valid;	HANDLE m_Handle;public:	CMacFileHandle() : m_Valid(false), m_Handle(0) { }	~CMacFileHandle() { Close(); }	void Close() { if (m_Valid) { m_Valid = false; FSClose((short) (size_t) m_Handle); } }	void OpenDataForkReadDenyWrite(const CMacFilePath& Path)	{		short sHandle;		ThrowMacError(FSpOpenDF(Path.GetFSSpec(), fsRdPerm | fsWrDenyPerm, &sHandle));		m_Handle = (HANDLE)(size_t)sHandle;		m_Valid = true;	}		void OpenDataForkReadDenyWrite(PCWSTR Path)	{		OpenDataForkReadDenyWrite(CMacFilePath(Path));	}	HANDLE GetMacFileHandle() { return m_Handle; }		operator HANDLE() { return GetMacFileHandle(); }};class CMacResourceFileHandle{	bool m_Valid;	HANDLE m_Handle;public:	CMacResourceFileHandle() : m_Valid(false), m_Handle(0) { }	~CMacResourceFileHandle() { Close(); }	void Close() { if (m_Valid) { m_Valid = false; CloseResFile((short) (size_t) m_Handle); } }	void OpenReadDenyWrite(const CMacFilePath& Path)	{		Close();		short Handle = FSpOpenResFile(Path.GetFSSpec(), fsRdPerm | fsWrDenyPerm);		if (Handle == -1)			ThrowMacError(ResError());		m_Handle = (HANDLE)(size_t)Handle;		m_Valid = true;	}		void OpenReadDenyWrite(PCWSTR Path)	{		Close();		OpenReadDenyWrite(CMacFilePath(Path));	}		HANDLE GetMacFileHandle() { return m_Handle; }	operator HANDLE() { return GetMacFileHandle(); }};inline PSTR p2cstr(UCHAR *s){	size_t Length = s[0];	memmove(&s[0], &s[1], Length);	s[Length] = 0;	return (PSTR)s;}