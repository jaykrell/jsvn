/*makealias2.cAuthor: Jay KrellAuthor email: jay.krell@cornell.eduSummary:  make Macintosh alias files without sending events to Finder  an approximate clone of MPW MakeAlias, not all switches implemented  Aliases can be made of regular files and regular directories though aliases    of various special directories and devices does not act like Finder.*/#include <stddef.h>#include <stdarg.h>#include <stdio.h>#include <stdio.h>#include <string.h>#include <stdlib.h>#include <ctype.h>#include "aliases.h"#include "textutils.h"#include "resources.h"#include "files.h"#include "finder.h"#include "errmgr.h"int string_equal(const char * s, const char * t){	return (strcmp(s, t) == 0);}void string_lower(char * s){	for ( ; *s ; ++s)	{		*s = tolower(*s);	}}void error_va(const char * format, va_list args){	vfprintf(stderr, format, args);}void error(const char * format, ...){	va_list args;		va_start(args, format);	error_va(format, args);	va_end(args);}void donothing_free(void * p){	p = p;}void usage(){	printf("# Usage -  makealias2 file [-o aliasName] [-y | -n | -c]\n");}/*Getting declarations for the c2pstr/p2cstr functions and linking to them across various runtime models (68k, cfm, carbon)seems to be more difficult than just writing them.*/long jk_copy_to_cstr(char * c, const void * from, size_t length){	memmove(c, from, length);	c[length] = 0;	return 0;}long jk_copy_to_pstr(unsigned char * p, const void * from, size_t length){	if (length > 255)		return -1;	memmove(p + 1, from, length);	p[0] = (unsigned char)length;	return 0;}long jk_copy_c2pstr(unsigned char * p, const char * c){	return jk_copy_to_pstr(p, c, strlen(c));}long jk_inplace_c2pstr(char * s){	return jk_copy_to_pstr((unsigned char*)s, s, strlen(s));}long jk_copy_p2cstr(char * c, const unsigned char * p){	return jk_copy_to_cstr(c, p + 1, p[0]);}long jk_inplace_p2cstr(unsigned char * s){	return jk_copy_to_cstr((char*)s, s + 1, s[0]);}long jk_malloc_c2pstr(unsigned char ** pout, const char * c){	unsigned char * p = 0;	size_t len = 0;		*pout = 0;	len = strlen(c);	if (len >= 256)	  return -1;	p = (unsigned char*)malloc(len + 1);	if (p == NULL)	  return -1;	*pout = p;	return jk_copy_to_pstr(p, c, len);}long jk_malloc_p2cstr(char ** cout, const unsigned char * p){	char * c = 0;	size_t len = 0;		*cout = 0;	len = p[0];	c = (char*)malloc(len + 1);	if (c == NULL)	  return -1;	*cout = c;	return jk_copy_to_cstr(c, p + 1, len);}void jk_mac_DisposeHandle(void ** handle){	void * h = *handle;	*handle = 0;	if (h != 0)	{		DisposeHandle(h);	}}void jk_mac_CloseResFile(short * file_handle){	short fh = *file_handle;	*file_handle = 0;	if (fh != 0)	{		CloseResFile(fh);	}}longjk_mac_GetAliasFileTypeAndCreater(	const FSSpec * fsspec,	unsigned long * type,	unsigned long * creater	){	CInfoPBRec cat_info;	long oserr = 0;	*type = 0;	*creater = 0;		memset(&cat_info, 0, sizeof(cat_info));		cat_info.hFileInfo.ioNamePtr = fsspec->name;	cat_info.hFileInfo.ioVRefNum = fsspec->vRefNum;	cat_info.hFileInfo.ioDirID = fsspec->parID;		oserr = PBGetCatInfoSync(&cat_info);	if (oserr != noErr)		goto exit;	if (cat_info.hFileInfo.ioFlAttrib & kioFlAttribDirMask)	{		*type = kContainerFolderAliasType;		*creater = 'MACS';	}	else	{		*type = cat_info.hFileInfo.ioFlFndrInfo.fdType;		*creater = cat_info.hFileInfo.ioFlFndrInfo.fdCreator;	}exit:	return oserr;}int main(int signed_argc, char ** argv){	const unsigned argc = signed_argc;	unsigned i = 0;	long line = __LINE__;	struct {		const char * cstr;		FSSpec fsspec;	} infile = { 0 };	struct {		short  file_handle;		char * cstr;		FInfo finder_info;		FSSpec fsspec;	} outfile = { 0 };	long oserr = noErr;	void (*free_outfile)(void *) = donothing_free;	int ret = EXIT_FAILURE;	int yes = 0;	int no = 0;	int cancel = 0;	AliasHandle alias_handle = 0;	short file_handle_temp = 0;	unsigned long file_type = 0;	unsigned long file_creater = 0;	Str255 pstr = { 0 };		for (i = 1 ; i != argc ; ++i)	{		char * arg = argv[i];		if (arg[0] == '-')		{			++arg;			string_lower(arg);			if (string_equal(arg, "?")				|| string_equal(arg, "h")				|| string_equal(arg, "help")				)			{				usage();				goto exit;			}			else if (string_equal(arg, "n"))			{				no = 1;			}			else if (string_equal(arg, "y"))			{				yes = 1;			}			else if (string_equal(arg, "c"))			{				cancel = 1;			}			else if (string_equal(arg, "o"))			{				++i;				if (i == argc)				{					usage();					goto exit;				}				else if (outfile.cstr == NULL)				{					outfile.cstr = argv[i];				}				else				{					usage();					goto exit;				}			}		}		else		{			if (infile.cstr == NULL)			{				infile.cstr = arg;			}			else if (outfile.cstr == NULL)			{				outfile.cstr = arg;			}			else			{				usage();				goto exit;			}		}	}		if (infile.cstr == NULL)	{		usage();		goto exit;	}	if (outfile.cstr == NULL)	{		outfile.cstr = (char*)malloc((strlen(infile.cstr) + sizeof(" alias") + 1) * sizeof(outfile.cstr[0]));		if (outfile.cstr == NULL)			goto exit;		free_outfile = free;		strcpy(outfile.cstr, infile.cstr);		strcat(outfile.cstr, " alias");	}	line = __LINE__;	if (jk_copy_c2pstr(pstr, infile.cstr) < 0)		goto exit;	line = __LINE__;	oserr = FSMakeFSSpec(0, 0, pstr, &infile.fsspec);	if (oserr != noErr)		goto exit;	line = __LINE__;	if (jk_copy_c2pstr(pstr, outfile.cstr) < 0)		goto exit;	line = __LINE__;	oserr = FSMakeFSSpec(0, 0, pstr, &outfile.fsspec);	if (oserr != noErr && oserr != fnfErr)		goto exit;	line = __LINE__;	oserr = NewAlias(NULL, &infile.fsspec, &alias_handle);	if (oserr != noErr)		goto exit;	line = __LINE__;	oserr = FSpDelete(&outfile.fsspec);	if (oserr != noErr && oserr != fnfErr)		goto exit;	line = __LINE__;	oserr = jk_mac_GetAliasFileTypeAndCreater(&infile.fsspec, &file_type, &file_creater);    if (oserr != noErr)		goto exit;	line = __LINE__;	FSpCreateResFile(&outfile.fsspec, file_creater, file_type, 0);    oserr = ResError();    if (oserr != noErr)		goto exit;	line = __LINE__;	oserr = FSpGetFInfo(&outfile.fsspec, &outfile.finder_info);	if (oserr != noErr)		goto exit;		line = __LINE__;	outfile.finder_info.fdFlags |= kIsAlias;	oserr = FSpSetFInfo(&outfile.fsspec, &outfile.finder_info);	if (oserr != noErr)		goto exit;	line = __LINE__;    file_handle_temp = FSpOpenResFile(&outfile.fsspec, fsRdWrPerm);    oserr = ResError();    if (oserr != noErr)		goto exit;	outfile.file_handle = file_handle_temp;		line = __LINE__;	AddResource((Handle)alias_handle, 'alis', 0, NULL);    oserr = ResError();    if (oserr != noErr)		goto exit;	alias_handle = NULL;	ret = EXIT_SUCCESS;	oserr = noErr;exit:	if (oserr != noErr)	{		char error_message[256] = { 0 };			error("# %s\n", GetSysErrText(oserr, error_message));		CloseErrMgr();		error("File %s; Line %ld\n", __FILE__, line + 1);	}	free_outfile(outfile.cstr);	jk_mac_CloseResFile(&outfile.file_handle);	jk_mac_DisposeHandle((void**)&alias_handle);	return ret;}